# 查找

## 考点总结



## 知识总结

![image-20230720151803579](./assets/image-20230720151803579.png)

![image-20230720163518914](./assets/image-20230720163518914.png)

![image-20230720171828290](./assets/image-20230720171828290.png)

![image-20230720193721514](./assets/image-20230720193721514.png)

![image-20230722161737579](./assets/image-20230722161737579.png)

![image-20230722202438050](./assets/image-20230722202438050.png)

![image-20230724142942715](./assets/image-20230724142942715.png)

![image-20230724163237627](./assets/image-20230724163237627.png)

![image-20230724163355112](./assets/image-20230724163355112.png)

![image-20230724163549182](./assets/image-20230724163549182.png)

![image-20230724173036104](./assets/image-20230724173036104.png)

![image-20230724181955470](./assets/image-20230724181955470.png)

![image-20230724195322682](./assets/image-20230724195322682.png)

![image-20230724202139255](./assets/image-20230724202139255.png)

![image-20230724213136956](./assets/image-20230724213136956.png)

![image-20230724220841760](./assets/image-20230724220841760.png)

![image-20230724221816325](./assets/image-20230724221816325.png)



## 基本概念

### 查找

**在数据集合中寻找满足某种条件的数据元素的过程称为查找**



### 查找表（查找结构）

用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成



### 关键字（类似数据库的主键，唯一不重复）

数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结构应该是唯一的



![image-20230720145132778](./assets/image-20230720145132778.png)

![image-20230720150747878](./assets/image-20230720150747878.png)



### 常见操作

- 操作

  1. 查找复合条件的数据元素

  2. 插入、删除某个数据元素
- 应用

  - 只需进行操作1——静态查找表（仅关注查找速度即可）

  - 也要进行操作2——动态查找表（除了查找速度，也要关注插/删操作是否方便实现）


![image-20230720151115044](./assets/image-20230720151115044.png)

### 评价指标

#### 查找长度

- 在查找运算中，需要对比关键字的次数称为查找长度



#### 平均查找长度（ASL，Average Search Length)

- 所有查找过程中进行关键字的比较次数的平均值

- **ASL的数量级反映了查找算法的时间复杂度**



![image-20230720151601756](./assets/image-20230720151601756.png)

![image-20230720151629670](./assets/image-20230720151629670.png)

![image-20230720151732726](./assets/image-20230720151732726.png)



## 顺序查找

- 顺序查找，又叫“线性查找”，通常用于线性表（顺序表，链表）

### 算法思想

- 从头到jio挨个找（反过来也ok）

![image-20230720152101739](./assets/image-20230720152101739.png)

![image-20230720152116493](./assets/image-20230720152116493.png)





### 算法实现

#### 代码实现（查找失败越界返回-1）

```C++
typedef struct{                     //查找表的数据结构（顺序表）
    Elemtype *elem;                 //动态数组基址
    int TableLen;                   //表的长度
}   SSTable;

//顺序查找1
int Search_Seq(SSTable ST, Elemtype key){
    int i;
    for(i = 0; i < ST.TableLen && ST.elem[i]!= key;++i);
    //查找成功，则返回元素下标；查找失败，则返回-1
    return i==ST.TableLen? -1:i;
    
}
```



![image-20230720153446093](./assets/image-20230720153446093.png)

![image-20230720153617255](./assets/image-20230720153617255.png)

#### 代码实现（哨兵）

- 优点：无需判断是否越界，效率更高

```C++
//顺序查找2（哨兵）
int Search_Seq(SSTable ST, Elemtype key){
    ST.elem[0]=key;                 //“哨兵”
    int i;
    for(int i = ST.TableLen; ST.elem[i]!=key; --i);//从后往前找
    return i;                       //查找成功，则返回元素下标；查找失败，则返回0
}
```

![image-20230720154028514](./assets/image-20230720154028514.png)

![image-20230720154051155](./assets/image-20230720154051155.png)



#### 效率分析

![image-20230720154501231](./assets/image-20230720154501231.png)



### 算法优化

#### 有序表

- 查找判定树

![image-20230720154713715](./assets/image-20230720154713715.png)

##### 用查找判定树分析ASL

- 一个成功节点的查找长度 = 自身所在层数
- 一个失败节点的查找长度 = 其父节点所在层数

- 默认情况下，各种失败情况或成功情况都等概率发生

![image-20230720154943367](./assets/image-20230720154943367.png)

#### 被查概率不相等

- 被查概率大的放在靠前位置

![image-20230720163441562](./assets/image-20230720163441562.png)



## 折半查找（有序的顺序表）

- 折半查找，又叫“二分查找”，仅适用于**有序的顺序表**
- 顺序表具有随机访问的特性，链表没有

### 算法思想

#### 查找成功

![image-20230720163809803](./assets/image-20230720163809803.png)

![image-20230720163832693](./assets/image-20230720163832693.png)

![image-20230720163850632](./assets/image-20230720163850632.png)

![image-20230720163947281](./assets/image-20230720163947281.png)

#### 查找失败

![image-20230720164025165](./assets/image-20230720164025165.png)

![image-20230720164043841](./assets/image-20230720164043841.png)

![image-20230720164059749](./assets/image-20230720164059749.png)

![image-20230720164111054](./assets/image-20230720164111054.png)

![image-20230720164144253](./assets/image-20230720164144253.png)

![image-20230720164129188](./assets/image-20230720164129188.png)

![image-20230720164229668](./assets/image-20230720164229668.png)

![image-20230720164240561](./assets/image-20230720164240561.png)

### 算法实现

#### 代码实现(升序数组)

```C++
typedef struct{                             //查找表的数据结构（顺序表）
    Elemtype *elem;                         //动态数组的基址
    int TableLen;                           //表的长度
}SSTable;

//折半查找
int Binary_Search(SSTable L,Elemtype key){
    int low=0, high = L.TableLen-1,mid;
    while(low <= high){
        mid=(low+high)/2;                   //取中间位置
        if(L.elem[mid]==key) return mid;    //查找成功则返回所在位置
        else if(L.elem[mid] > key) high = mid-1;    //从前半部分继续查找
        else low = mid + 1;                 //从后半部分继续查找
    }
    return -1;                              //查找失败，返回-1
}
```

![image-20230720164831854](./assets/image-20230720164831854.png)

#### 效率分析

![image-20230720165155165](./assets/image-20230720165155165.png)

![image-20230720165232737](./assets/image-20230720165232737.png)

### 折半查找判定树的构造（重点）

#### 奇数个

![image-20230720165422920](./assets/image-20230720165422920.png)

![image-20230720165449422](./assets/image-20230720165449422.png)

#### 偶数个

- 如果当前low和high之间有偶数个元素，则mid分隔后，左半部分比右半部分少一个元素
- 如果当前low和high之间有奇数个元素，则mid分隔后，左右两部分元素个数相等
- mid=[(low+high)/2]，则对任何一个节点，必有：**右子树节点数-左子树节点数=0/1**（右子树节点数比左子树多）

![image-20230720165535360](./assets/image-20230720165535360.png)

![image-20230720165555996](./assets/image-20230720165555996.png)

![image-20230720165908597](./assets/image-20230720165908597.png)

#### 构造方法及性质

- 构造的形状唯一
- 折半查找的判定树一定是平衡二叉树，只有最下面一层是不满的（元素个数为n时，树高h=[log2(n+1)]向上取整）
- 新节点优先右子树，但是右子树只能最多比左子树多一个
  - 左右子树相等，新节点加到右子树
  - 左右子树不相等（右子树比左子树节点多），新节点加到左子树

![image-20230720170738197](./assets/image-20230720170738197.png)
![image-20230720171045853](./assets/image-20230720171045853.png)

#### 性质

- 判定树节点关键字：左<中<右，满足二叉排序树的定义
- 失败节点：n+1个（等于成功节点的空链域数量）



![image-20230720171259153](./assets/image-20230720171259153.png)

![image-20230720171558671](./assets/image-20230720171558671.png)

#### 查找效率

- 树高h = [log2(n+1)]向上取整（不包括失败节点）
  - 查找成功：ASL <= h
  - 查找失败：ASL <= h
  - 时间复杂度 = O(log2n)

![image-20230720172600920](./assets/image-20230720172600920.png)



#### 另一种情况的折半查找

- mid = [(low+high)/2]向上取整

![image-20230720172215927](./assets/image-20230720172215927.png)

![image-20230720172253774](./assets/image-20230720172253774.png)

![image-20230720172400811](./assets/image-20230720172400811.png)





### 折半查找的速度一定比顺序查找更快？

- 大部分情况下，折半查找更快；但不是任何情况下都更快

- 折半查找时间复杂度 = O(log2n)
- 顺序查找的时间复杂度 = O(n)

![image-20230720172019138](./assets/image-20230720172019138.png)

## 分块查找（选择题）

- **分块查找**，又称**索引顺序查找**



### 算法思想（顺序查找和折半查找的结合）

- 索引表：保存每个分块的最大关键字和分块的存储区间

![image-20230720174031300](./assets/image-20230720174031300.png)

### 过程

- 算法过程如下：
  1. 在索引表中确定待查记录所属的分块（可顺序、可折半）（索引表是有序的）
     - 查找目标 > 索引值：下一个
     - 查找目标 <= 索引值：选择该索引范围
  2. 在块内顺序查找（块内的元素是无序的）



#### 查找成功

![image-20230720174148215](./assets/image-20230720174148215.png)

![image-20230720174234584](./assets/image-20230720174234584.png)

![image-20230720174246063](./assets/image-20230720174246063.png)

![image-20230720174502881](./assets/image-20230720174502881.png)

![image-20230720174518270](./assets/image-20230720174518270.png)

#### 查找失败

![image-20230720174607035](./assets/image-20230720174607035.png)

![image-20230720174620988](./assets/image-20230720174620988.png)

![image-20230720174630296](./assets/image-20230720174630296.png)

![image-20230720174656119](./assets/image-20230720174656119.png)

![image-20230720174704687](./assets/image-20230720174704687.png)

![image-20230720174716649](./assets/image-20230720174716649.png)

![image-20230720174724729](./assets/image-20230720174724729.png)

![image-20230720174750762](./assets/image-20230720174750762.png)



#### 用折半查找查索引

- 查找目标在索引表里面

![image-20230720175129067](./assets/image-20230720175129067.png)

![image-20230720175213153](./assets/image-20230720175213153.png)

![image-20230720175252687](./assets/image-20230720175252687.png)

![image-20230720175232459](./assets/image-20230720175232459.png)

#### 用折半查找查索引2

- 查找目标不在索引表里面
- 若索引表中不包含目标关键字，则折半查找索引表最终停在low>high,**要在low所指分块中查找**
  - 原因：最终low左边一定小雨目标关键字，high右边一定大雨目标关键字。而分块存储的索引表中保存的是各个分块的最大关键字

![image-20230720175443863](./assets/image-20230720175443863.png)

![image-20230720175500012](./assets/image-20230720175500012.png)

![image-20230720175516433](./assets/image-20230720175516433.png)

![image-20230720175535318](./assets/image-20230720175535318.png)

![image-20230720175606707](./assets/image-20230720175606707.png)

![image-20230720175624368](./assets/image-20230720175624368.png)

![image-20230720192236475](./assets/image-20230720192236475.png)

![image-20230720192252235](./assets/image-20230720192252235.png)

![image-20230720192305940](./assets/image-20230720192305940.png)

#### 查找失败

![image-20230720192347781](./assets/image-20230720192347781.png)

### 查找效率分析（ASL）

#### 查找成功

![image-20230720192435475](./assets/image-20230720192435475.png)

![image-20230720192531733](./assets/image-20230720192531733.png)

- 30：4次
- 27：不是2次。因为27不在索引表中，要增加三次直到找到索引表的位置



![image-20230720192735045](./assets/image-20230720192735045.png)

#### 查找失败

![image-20230720192825925](./assets/image-20230720192825925.png)

#### 效率优化

- 假设：长度为n的查找表被均匀地分为b块，每块s个元素          n=s*b

- 设索引查找和块内查找的平均查找长度分别为L1、L2，则分块查找的平均查找长度为ASL=Li+Ls
  - 用**顺序查找**查索引表
    - ASL=1/2\*s + n/2\*s + 1
    - 最小的ASL = 根号n+1（当s = 根号n，b = 根号n）
  - 用**折半查找**查索引表

![image-20230720193338939](./assets/image-20230720193338939.png)

![image-20230720193658770](./assets/image-20230720193658770.png)

## 树形查找

### 二叉排序树

#### 定义

- 二叉排序树，又称二叉查找树（**BST**，Binary Search Tree）
- 一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：
  - 左子树上所有节点的关键字均小于根节点的关键字
  - 右子树上所有节点的关键字均大于根节点的关键字
  - 左子树和右子树又各是一棵二叉排序树
- 左子树节点值 < 根节点值 < 右子树节点值
  - 进行中序遍历，可以得到一个递增的有序序列
- 二叉排序树可用于元素的有序组织、搜索

![image-20230721222332589](./assets/image-20230721222332589.png)





#### 查找操作

- 若树非空，目标值与根节点的值比较：
  - 若相等，则查找成功
  - 若小于根节点，则在左子树上查找，否则在右子树上查找
- 查找成功，返回节点指针
- 查找失败返回NULL



##### 查找成功

![image-20230721222616468](./assets/image-20230721222616468.png)

![image-20230721223154791](./assets/image-20230721223154791.png)

##### 查找失败

![image-20230721223604519](./assets/image-20230721223604519.png)

#### 代码实现

- 有两种实现方式
  - 一种是非递归
    -  while(T != NULL && key != T->key);
  - 一种是递归
    - return BST_Search2(T->lchild, key); 

```C++

//二叉排序树节点
typedef struct BSTNode{
    int key;
    struct BSTNode *lchild, *rchild;
}BSTNode, *BSTree;


//在二叉排序树中查找值为key的节点（非递归）
BSTNode *BST_Search(BSTree T, int key){
    while(T != NULL && key != T->key){      //若树空或等于根节点值，则结束循环
        if(key < T->key) T = T -> lchild;   //小于，则在左子树上查找
        else T = T->rchild;                 //大于，则在右子树上查找
    }
    return T;
}

//二叉排序树中寻找值为key的节点（递归）
BSTNode *BST_Search2(BSTree T, int key){
    if(T==NULL) return NULL;                //查找失败
    if(key == T->key)  return T;            //查找成功
    else if(key < T->key) return BST_Search2(T->lchild, key);       //在左子树中找
    else return BST_Search2(T->rchild, key);                        //在右子树中找
}
```



![image-20230722130753338](./assets/image-20230722130753338.png)

#### 插入操作

- 若原二叉排序树为空，则直接插入节点
- 若二叉排序树不为空
  - 若关键字k小于根节点值，则插入到左子树
  - 若关键字k大于根节点值，则插入到右子树

##### 算法实现

![image-20230722143338669](./assets/image-20230722143338669.png)

##### 代码实现（递归）

```C++
//在二叉排序树插入关键字为k的新节点（递归实现）
int BST_Insert(BSTree &T, int k){
    if(T==NULL){                            //原数为空，新插入的节点为根节点
        T=(BSTree)malloc(sizeof(BSTNode));
        T->key = k;
        T->lchild=NULL;
        T->rchild=NULL;
        //T->lchild = T->rchild = NULL;
        return 1;                           //返回1，插入成功
    }
    else if(k==T->key)                      //树中存在相同关键字的结点，插入失败
        return 0;
    else if(k<T->key)                       //插入T的左子树
        return BST_Insert(T->lchild, k);  
    else return BST_Insert(T->rchild, k);   //插入T的右子树
}
```

##### 代码实现（非递归）



#### 二叉排序树的构造

- 不同的关键字序列可能得到同款二叉排序树

![image-20230722143918303](./assets/image-20230722143918303.png)

```C++
//按照str[]中的关键字序列建立二叉排序树
void Creat_BST(BSTree &T, int str[], int n){
    T = NULL;                               //初始时，T为空树
    int i = 0;
    while(i < n){                           //依次将每个关键字插入到二叉排序树中
        BST_Insert(T,str[i]);
        i++;
    }

}
```

- 相同的关键字，不同排列可能得到不同款的二叉排序树

![image-20230722143956854](./assets/image-20230722143956854.png)

#### 删除操作

- 先搜索找到目标节点
  - 若被删除节点z是叶子节点，则直接删除，不会破坏二叉排序树的性质
  - 若被删除节点z只有一棵左子树或右子树，则让z的子树成为z父节点的子树，代替z的位置
  - 若被删除节点z有左右两棵子树，则令z的直接后继（或直接前驱）代替z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况
    - 原理
      - 左子树 < 根节点 < 右子树
      - 进行中序遍历，可以得到一个递增的有序序列
      - 所以将左子树中最后一个被中序遍历的（左边最大的），或者右子树中最早一个被中序遍历的（右边最小的）删去，放到删除的节点上，就可以保证中序遍历结果不变，且能保持二叉排序树

![image-20230722144151517](./assets/image-20230722144151517.png)

![image-20230722144258357](./assets/image-20230722144258357.png)

![image-20230722144902838](./assets/image-20230722144902838.png)

![image-20230722145007236](./assets/image-20230722145007236.png)

![image-20230722145028053](./assets/image-20230722145028053.png)

![image-20230722145040306](./assets/image-20230722145040306.png)



#### 查找效率分析

- 查找长度
  - 在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度



##### 查找成功

- ASL，查找成功的平均查找长度
- 若树高h，找到最下层的一个节点需要对比h次
- 最好情况
  - n个节点的二叉树最小高度为[log2n]向下取整+1
  - 平均查找长度 = O(log2n)

- 最坏情况
  - 每个节点只有一个分支
  - 树高h = 节点数n
  - 平均查找长度 = O(n)


![image-20230722145307895](./assets/image-20230722145307895.png)



##### 查找失败

![image-20230722145836191](./assets/image-20230722145836191.png)



##### 最好情况

- 平衡二叉树，树上任一节点的左子树和右子树的深度之差不超过1

![image-20230722145755248](./assets/image-20230722145755248.png)



### 平衡二叉树

#### 定义

- 平衡二叉树（Balanced Binary Tree），简称平衡树（AVL树）
  - 树上任一节点的左子树和右子树的高度之差不超过1
- 结点的平衡因子 = 左子树高 - 右子树高
  - 平衡二叉树节点的平衡因子值只可能是-1，0，1
  - 只要有任一节点的平衡因子绝对值大于1，就不是平衡二叉树

![image-20230722151329439](./assets/image-20230722151329439.png)

- 结构体定义

```C++
//平衡二叉树结构体定义
typedef struct AVLNode
{
    int key;                        //数据域
    int balancel;                    //平衡因子
    struct AVLNode *lchild, *rchild;    
}AVLNode, *AVLTree;
```



#### 插入操作

- 每次插入新节点后，调整**最小不平衡子树**
- 在插入操作中，只要将最小不平衡子树调整平衡，则其他祖先节点都会恢复平衡



![image-20230722151905858](./assets/image-20230722151905858.png)



#### 插入新节点后如何调整“不平衡”问题

##### 不平衡情况

- LL：在A的左孩子的左子树中插入导致不平衡
- RR：在A的右孩子的右子树中插入导致不平衡
- LR：在A的左孩子的右子树中插入导致不平衡
- RL：在A的右孩子的左子树中插入导致不平衡

![image-20230722152244959](./assets/image-20230722152244959.png)

##### 调整最小不平衡子树

- 插入新节点前，应该是有平衡因子为1或-1的情况，即左子树与右子树不相等

- 插入新节点后，平衡因子为2或-2导致不平衡

- 目标

  - 恢复平衡
  - 保持二叉排序树的特性
    - 左子树节点值 < 根节点值 < 右子树节点值

- LL：右单旋转

  - 原因：在节点A的左孩子的左子树上插入了新节点，A的平衡因子由1增加到2
  - 操作：将A的左孩子B向右上旋转代替A成为根节点，将A节点向右下旋转成为B右子树的根节点，B原右子树作为A的左子树
  
- RR：左单旋转
  
  - 在节点A的右孩子的右子树上插入了新节点，A的平衡因子由-1减小到-2
  - 操作：将A的右孩子B向左上旋转代替A成为根节点，将A节点向左下旋转成为B的左子树的根节点，而B的原左子树则作为A节点的右子树
  
  
  

###### LL：右旋

- 原因：在节点A的左孩子的左子树上插入了新节点，A的平衡因子由1增加到2
- 操作：将A的左孩子B向右上旋转代替A成为根节点，将A节点向右下旋转成为B右子树的根节点，B原右子树作为A的左子树

![image-20230722152648580](./assets/image-20230722152648580.png)

###### RR：左旋

- 在节点A的右孩子的右子树上插入了新节点，A的平衡因子由-1减小到-2
- 操作：将A的右孩子B向左上旋转代替A成为根节点，将A节点向左下旋转成为B的左子树的根节点，而B的原左子树则作为A节点的右子树

![image-20230722153725461](./assets/image-20230722153725461.png)

###### 代码思路

![image-20230722154139187](./assets/image-20230722154139187.png)

###### LR：先左后右

- 原因：由于在A的左孩子的右子树上插入新节点，A的平衡因子由1增加到2
- 操作：先将A节点的左孩子B的右子树的根节点C向左上旋转提升到B节点的位置，然后再把C节点向右上旋转提升到A节点的位置

![image-20230722154639021](./assets/image-20230722154639021.png)

![image-20230722154709712](./assets/image-20230722154709712.png)

![image-20230722154725853](./assets/image-20230722154725853.png)

###### RL：先右再左

- 原因：在A的右孩子的左子树上插入新节点，A的平衡因子由-1减到-2，导致以A为根的子树失去平衡
- 操作：先将A节点的左孩子B的根节点C向右上旋转提升到B节点的位置，然后再把该C节点向左上旋转提升到A节点的位置

![image-20230722154920933](./assets/image-20230722154920933.png)

![image-20230722154933284](./assets/image-20230722154933284.png)

![image-20230722154945762](./assets/image-20230722154945762.png)



###### 总结

- 只有左孩子才能右上旋
- 只有右孩子才能左上旋

![image-20230722155327108](./assets/image-20230722155327108.png)



##### 只要调整最小平衡子树，其他祖先节点就能恢复平衡

- 插入操作导致“最小不平衡子树”高度+1，经过调整后高度恢复

![image-20230722155532175](./assets/image-20230722155532175.png)

![image-20230722155716901](./assets/image-20230722155716901.png)

![image-20230722155730461](./assets/image-20230722155730461.png)

###### 练习

- RR
  - 找到第一个不平衡的点
  - 往下数一个节点——作为新的跟节点
  - 旧根节点作为新根节点的左子树
  - 新根节点原来的左子树变成左子树的右子树

![image-20230722160123223](./assets/image-20230722160123223.png)

![image-20230722160133825](./assets/image-20230722160133825.png)



- RL
  - 找到第一个不平衡的节点
  - 往下数两个节点——新的根节点
  - 往下数的第一个节点是新根节点的左节点，旧根节点是新根节点的右节点
  - 新根节点原先的左子树给到左边的右子树
  - 新根节点原来的右子树给到右边的左子树

![image-20230722160145092](./assets/image-20230722160145092.png)

![image-20230722160404268](./assets/image-20230722160404268.png)

![image-20230722160548581](./assets/image-20230722160548581.png)

- LR

![image-20230722160839925](./assets/image-20230722160839925.png)

![image-20230722160851663](./assets/image-20230722160851663.png)



#### 查找效率分析

- 若树高为h，最坏情况下查找一个关键字最多需要对比h次，即查找操作的时间复杂度不肯呢个超过O(h)
- 所以应该尽可能降低树高
  - 假设以nh表示深度为h的平衡树中含有的最少节点数
  - 则有n0 = 0, n1 = 1, n2 = 2,并且nh = n(h-1) + n(h-2) + 1（n(h-1)：h-1层最少的节点数；n(h-2)：h-2层最少的节点数）
- 平均查找长度：O(log2n)

![image-20230722161325806](./assets/image-20230722161325806.png)



#### 删除操作

##### 插入 VS 删除

- 平衡二叉树的插入操作
  - 插入新节点后，要保持二叉排序树的特性不变（左<中<右）
  - 若插入新节点导致不平衡，则需要调整平衡
- 平衡二叉树的删除操作
  - 删除节点后，要保持二叉排序树的特性不变
  - 若删除节点导致不平衡，则需要调整平衡



##### 具体步骤

- 平衡二叉树删除操作
  - 删除节点（方法同“二叉排序树”）
    - 若被删除节点z是叶子节点，则直接删除，不会破坏二叉排序树的性质
    - 若被删除节点z只有一棵左子树或右子树，则让z的子树成为z父节点的子树，代替z的位置
    - 若被删除节点z有左右两棵子树，则令z的直接后继（或直接前驱）代替z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况
  - 一路向上找到最小不平衡子树，找不到就完结撒花
  - 找最小不平衡子树下，个头最高的儿子、孙子
  - 根据孙子的位置，调整平衡（LL/RR/LR/RL）
  - 如果不平衡向上传导，继续2



##### 例一：未出现不平衡现象

![image-20230722170523667](./assets/image-20230722170523667.png)

##### 例二：出现不平衡现象

![image-20230722170659751](./assets/image-20230722170659751.png)

- 寻找最小不平衡子树

![image-20230722170711073](./assets/image-20230722170711073.png)

- 寻找个头最高的儿子、孙子

![image-20230722170841722](./assets/image-20230722170841722.png)

- 根据孙子的位置，调整平衡

![image-20230722171008471](./assets/image-20230722171008471.png)

![image-20230722171059051](./assets/image-20230722171059051.png)



- 检查不平衡性是否向上传导（高度减少引起的）

![image-20230722171140684](./assets/image-20230722171140684.png)



##### 例三：出现不平衡现象

- 删除节点

![image-20230722171239949](./assets/image-20230722171239949.png)

- 找到最小不平衡子树

![image-20230722171327214](./assets/image-20230722171327214.png)

- 找个头最高的儿子、孙子

![image-20230722171353783](./assets/image-20230722171353783.png)

- 根据孙子的位置，调整平衡

![image-20230722174330718](./assets/image-20230722174330718.png)

![image-20230722174426010](./assets/image-20230722174426010.png)

![image-20230722174437084](./assets/image-20230722174437084.png)

- 寻找传导

![image-20230722174450964](./assets/image-20230722174450964.png)



##### 例四：出现不平衡传导现象

- 删除节点

![image-20230722174533792](./assets/image-20230722174533792.png)

- 找到最小不平衡子树

![image-20230722174546095](./assets/image-20230722174546095.png)

- 找到向上传导的不平衡子树

![image-20230722174556963](./assets/image-20230722174556963.png)

- 找到最小不平衡子树

![image-20230722174608517](./assets/image-20230722174608517.png)

- 找到个头最高的儿子、孙子

![image-20230722174626038](./assets/image-20230722174626038.png)

- 根据孙子位置，调整平衡

![image-20230722174636891](./assets/image-20230722174636891.png)

![image-20230722174647349](./assets/image-20230722174647349.png)

- 寻找向上传导的不平衡

![image-20230722174747828](./assets/image-20230722174747828.png)

##### 例五：删除的节点不是叶子节点（前驱/后继  不太可能考）

- 按照二叉排序树的顺序，删除叶子节点



![image-20230722174804992](./assets/image-20230722174804992.png)

![image-20230722201032502](./assets/image-20230722201032502.png)

![image-20230722201306385](./assets/image-20230722201306385.png)

- 寻找最小不平衡树

![image-20230722201429690](./assets/image-20230722201429690.png)

- 找到个头最高的儿子、孙子

![image-20230722201455517](./assets/image-20230722201455517.png)

- 根据孙子的位置，调整平衡

![image-20230722201520289](./assets/image-20230722201520289.png)

- 寻找向上传导的不平衡子树

![image-20230722201551458](./assets/image-20230722201551458.png)

##### 例六：孙子/儿子个头相等（不太可能考）

- 删除节点

![image-20230722201847149](./assets/image-20230722201847149.png)

![image-20230722201857078](./assets/image-20230722201857078.png)

- 找到最小不平衡子树

![image-20230722201908691](./assets/image-20230722201908691.png)

- 找到个头最高的儿子、孙子（这里孙子个头相等）
- 假设选择右孙子

![image-20230722201921210](./assets/image-20230722201921210.png)

![image-20230722201955749](./assets/image-20230722201955749.png)

- 寻找传导

![image-20230722202222835](./assets/image-20230722202222835.png)



- 找到个头最高的儿子、孙子（这里孙子个头相等）
- 假设选择左孙子

![image-20230722202307745](./assets/image-20230722202307745.png)

- RL：调整平衡

![image-20230722202329133](./assets/image-20230722202329133.png)



![image-20230722202346340](./assets/image-20230722202346340.png)

- 寻找传导

![image-20230722202402979](./assets/image-20230722202402979.png)



### 红黑树（RBT）

#### 定义

##### 为什么要发明红黑树？

- 为什么要发明红黑树？

  - 平衡二叉树AVL

    - 插入/删除太麻烦了，适用于以查为主，很少插入/删除的场景
    - 插入/删除很容易破坏“平衡”特性，需要频繁调整树的形态
    - 插入操作导致不平衡，则需先计算平衡因子，找到最小不平衡子树（时间开销大），再进行LL/RR/LR/RL调整

  - 红黑树RBT

    - 适用于频繁删除/插入的场景，实用性更强
    - 插入/删除 很多时候不会破坏“红黑”特性，无需频繁调整树的形态。
    - 即使需要调整，一般都可以在常数级时间内完成

    

![image-20230722203124639](./assets/image-20230722203124639.png)

##### 红黑树大概会怎么考？

![image-20230722204326527](./assets/image-20230722204326527.png)

##### 基本定义

- 红黑树是二叉排序树
  - 左子树节点值 < 根节点值 < 右子树节点值
- 与普通BST相比有什么要求？
  - 每个节点或是红的，或是黑的
  - **根节点是黑的**
  - **叶节点**（外部节点、NULL节点、失败节点）均是**黑色**的
  - **不存在两个相邻的红节点**（即红节点的父节点和孩子节点均是黑色的）
  - 对每个节点，从该节点到任一叶节点的简单路径上，所含**黑节点的数目**相同

![image-20230722205005924](./assets/image-20230722205005924.png)



```C++
#define Elemtype int

struct RBNode{              //红黑树的节点定义
    int key;                //关键字的值
    RBNode* parent;         //父节点指针
    RBNode *lchild;         //左孩子指针
    RBNode *rchild;         //右孩子指针
    int color;              //节点颜色，如：可用0/1 表示 黑/红，也可以用枚举类型enum表示颜色

};
```



![image-20230722205045602](./assets/image-20230722205045602.png)

#### 练习

![image-20230722205411210](./assets/image-20230722205411210.png)

![image-20230722205423079](./assets/image-20230722205423079.png)

![image-20230722205753797](./assets/image-20230722205753797.png)

![image-20230722205902071](./assets/image-20230722205902071.png)

![image-20230722205918687](./assets/image-20230722205918687.png)

#### 节点的黑高bh

- 从某节点出发（不含该节点）到达任一空叶节点的路径上黑节点总数

![image-20230722210040059](./assets/image-20230722210040059.png)

#### 性质

- 节点的黑高bh——从某节点出发（不含该节点）到达任一叶节点的路径上黑节点总数
- 根节点黑高为h的红黑树，内部节点数（关键字）至少有多少个
  - 满二叉树，并且节点全为黑
  - 内部节点个数至少为2^h-1
- 根节点黑高为h的红黑树，内部节点最多有多少个？
  - h层黑节点，每一层黑节点下都铺满一层红节点。共2h层的满树状态
  - 最多有2^2h - 1个

- 性质一：**从根节点到叶节点的最长路径不大于最短路径的二倍**
  - 左右子树的高度相差不到2倍（条件更宽松，不太容易被破坏）
  - 而平衡二叉树AVL要求左右子树高度差不超过1（条件更严格，很容易被破坏）
  - 任何一条查找失败路径上黑节点数量都是相同的，而路径上不能连续出现两个红节点，即红节点只能穿插在各个黑节点中间

- 性质二：**有n个内部节点的红黑树高度 h <= 2log2(n+1)**
  - 若红黑树总高度=h，则根节点黑高>h/2，因此内部节点数n>=2^(h/2)-1，由此推出h <= 2log2(n+1)

- 查找时间复杂度 = O(log2n)

![image-20230724161947156](./assets/image-20230724161947156.png)

![image-20230724162337908](./assets/image-20230724162337908.png)

![image-20230722210146870](./assets/image-20230722210146870.png)

![image-20230724162601947](./assets/image-20230724162601947.png)



#### 插入操作

- 先查找，确认插入位置（原理同二叉排序树），插入新节点
- 新节点是**根**——染为黑色
- 新节点是非根——染为红色
  - 若插入新节点后依然满足红黑树的定义，则插入结束
  - 若插入新节点后不满足红黑树的定义，需要调整，使其重新满足红黑树定义
    - 黑叔：旋转+染色
      - LL型：右单旋转，父换爷+染色
      - RR型：左单旋转，父换爷+染色
      - LR型：左、右双旋，儿换爷+染色
      - RL型：右、左双旋，儿换爷+染色
    - 红叔：染色+变新
      - 叔父爷染色，爷变为新节点



![image-20230723233820042](./assets/image-20230723233820042.png)

##### 插入操作举例

- 左根右：按照二叉排序树的方式插入
- 根叶黑：很容易添加和判断，根节点和为NULL的叶子节点
- 黑路同：添加的都是非根节点，都为红色，所以不会破坏
- **不红红**
  - 是添加新节点所破坏的特性
  - 看叔叔颜色



- 黑叔叔：旋转+染色
  - LL：右单旋转，父爷染色

![image-20230724135626653](./assets/image-20230724135626653.png)



- 红叔叔：染色+变新
  - 叔父爷（三个）染色，爷变为新节点（有可能爷违反不红红特性）



![image-20230724140956016](./assets/image-20230724140956016.png)

- 黑叔叔：旋转+染色
  - RR：左单旋转，父爷染色

![image-20230724141105719](./assets/image-20230724141105719.png)

- 红叔叔：染色+变新
  - 叔父爷染色，爷变为新节点

![image-20230724141150466](./assets/image-20230724141150466.png)

- 不需要变色

![image-20230724141235255](./assets/image-20230724141235255.png)

- 黑叔叔：旋转+染色
  - LL：右单旋转，父爷染色

![image-20230724141251547](./assets/image-20230724141251547.png)

- 红叔叔：染色+变新
  - 叔父爷染色，爷变为新节点

![image-20230724141330082](./assets/image-20230724141330082.png)

- 不需要变色

![image-20230724141531171](./assets/image-20230724141531171.png)

- 不需要变色

![image-20230724141557266](./assets/image-20230724141557266.png)

- 不需要变色

![image-20230724141700165](./assets/image-20230724141700165.png)

- 红叔叔：染色+变新
  - 叔父爷染色，爷变为新节点
  - 如果根节点变为红色，要变成黑色



![image-20230724141717596](./assets/image-20230724141717596.png)

- 黑叔叔：旋转+染色
  - LR型：左右双旋，儿爷染色

![image-20230724142107748](./assets/image-20230724142107748.png)

- 黑叔叔：旋转+染色
  - LR型：左右双旋，儿爷染色

![image-20230724142204185](./assets/image-20230724142204185.png)

- 黑叔叔：旋转+染色
  - LR：左右双旋，儿爷染色

![image-20230724142241883](./assets/image-20230724142241883.png)

- 黑叔叔：旋转+染色
  - LR型：左右双旋，儿爷染色

![image-20230724142320887](./assets/image-20230724142320887.png)

- 红叔叔：染色+变新
  - 叔父爷染色，爷变为新节点



![image-20230724142400447](./assets/image-20230724142400447.png)

- 红叔叔：染色+变新
  - 叔父爷染色，爷变为新节点



![image-20230724142430892](./assets/image-20230724142430892.png)

- 黑叔叔：旋转+染色
  - LR型：左右双旋，儿爷染色



![image-20230724142519774](./assets/image-20230724142519774.png)

- 黑叔叔：旋转+染色
  - LR型：左右双旋，儿换爷+染色



![image-20230724142555702](./assets/image-20230724142555702.png)

- 黑叔叔：旋转+染色
  - LR型：左右双旋，儿爷染色

![image-20230724142634110](./assets/image-20230724142634110.png)

- 黑叔叔：旋转+染色
  - LR型：左右双旋，儿爷染色

![image-20230724142709720](./assets/image-20230724142709720.png)

- 不需要变色

![image-20230724142753160](./assets/image-20230724142753160.png)



- 黑叔叔：旋转+染色
  - RL型：右左双旋，儿爷染色

![image-20230724142805621](./assets/image-20230724142805621.png)

![image-20230724142851819](./assets/image-20230724142851819.png)

![image-20230724142908091](./assets/image-20230724142908091.png)

![image-20230724142918548](./assets/image-20230724142918548.png)

#### 删除操作（不考）

##### 性质

- 红黑树删除操作的时间复杂度=O(log2n)
- 在红黑树中删除节点的处理方式和“二叉排序树的删除一样”
- 按上述删除节点后，可能破坏红黑树特性，此时需要调整及诶单颜色、位置，使其在此满足红黑树特性

![image-20230724163228077](./assets/image-20230724163228077.png)



### B树

- 考察的主要是性质和手算方法
- 如果每个节点只有一个关键字——二叉排序树



#### 节点定义

![image-20230724164208501](./assets/image-20230724164208501.png)

- 二叉排序树节点

```C++
typedef struct BSTNode{
  int key;
  struct BSTNode *lchild, *rchild;
}BSTNode, *BSTree;
```

- 5叉排序树

![image-20230724164413840](./assets/image-20230724164413840.png)

```C++
struct Node{
    Elemtype keys[4];                   //最多4个关键字
    struct Node* child[55];             //最多5个孩子
    int num;                            //节点中有几个关键字
};

```



#### 查找操作

- 节点中keys是顺序排放的，每个节点内也可以采用折半查找

##### 查找成功

![image-20230724165022783](./assets/image-20230724165022783.png)

![image-20230724165036215](./assets/image-20230724165036215.png)



##### 查找失败

![image-20230724165157934](./assets/image-20230724165157934.png)

![image-20230724165216572](./assets/image-20230724165216572.png)

#### 如何保证查找效率

##### 问题

- 若每个节点内关键字太少，导致树变高，要查更多层节点，效率变低

- 不够平衡，树会很高，要查很多层节点

![image-20230724170105992](./assets/image-20230724170105992.png)

![image-20230724170133321](./assets/image-20230724170133321.png)



##### 策略

- m叉查找树中，规定除了根节点外，任何节点至少有[m/2]个分叉，即至少含有 [m/2]-1 个关键字
  
  - Eg：5叉排序树，规定除了根节点外，任何节点都至少有3个分叉，2个关键字
  
  - 为什么除了根节点外？
    - 如果整个树只有一个元素，根节点只有两个分叉
  
- m叉排序素中，规定对于任何一个节点，其所有子树的高度都要相同

![image-20230724165555484](./assets/image-20230724165555484.png)

![image-20230724165844965](./assets/image-20230724165844965.png)

![image-20230724170138709](./assets/image-20230724170138709.png)



#### B树定义

- B树，又称多路平衡查找树
  - B树中所被允许的孩子个数的最大值成为**B树的阶**，通常用m表示
  - 一棵m阶B树或为空树，或为满足以下特性的m叉树
    - 树中每个节点最多有m棵子树，即至多含有m-1个关键字
    - 若根节点不是终端节点，则至少有两棵子树
    - 除根节点外的所有非叶节点至少有  **[m/2]向上取整**  棵子树，即至少含有[m/2]-1个关键字
    - 所有的叶节点都出现在同一层次上，并且不带信息（可以视为外部节点或类似于折半查找判定树的查找失败节点，实际上这些节点不存在，指向这些节点的指针为空）
    - 所有非叶子节点的结构如下：
      - n：节点中关键字的个数（[m/2]-1 <= n <= m-1）
      - Ki：节点的关键字，且满足 K1 < K2 < .... < Kn
      - Pi：指向子树根节点的指针，且指针Pi-1所指子树中所有节点的关键字均小于Ki，Pi所指子树中所有节点的关键字均大于Ki



![image-20230724170426451](./assets/image-20230724170426451.png)

![image-20230724171123621](./assets/image-20230724171123621.png)

#### 核心特性

1. 根节点的子树数[2,m]，关键字数[1,m-1]

   其他节点的子树数[m/2,m]，关键字数[[m/2-1,m-1]]

2. 对任一节点，其所有子树高度相同

3. 关键字的值：子树0 < 关键字1 < 子树1 < 关键字2 < 子树2 <...（类似二叉查找树 左 < 中 < 右）

![image-20230724171823380](./assets/image-20230724171823380.png)

#### B树的高度

- B树的高度不包括叶子节点（失败节点）

- 含有n个关键字的m阶B树，最小高度、最大高度是多少？

  - 最小高度——让每个节点尽可能的满，有m-1个关键字，m个分叉，则有

    n <= (m-1)(1 + m + m^2 + m^3 +... + m^(h-1)) = m^h -1

    h >= logm(n+1)

  - 最大高度——让各层的分叉尽可能的少，即根节点只有两个分叉，其他节点只有[m/2]个分叉

    各层的节点至少有：第一层 1、第二层 2、第三层 2[m/2] ... 第h层2([m/2])^(h-2)

    第h+1层共有叶子节点（失败节点） 2([m/2])^(h-1) 个

    n个关键字的B树必有n+1个叶子节点，则 n+1 >= 2([m/2])^(h-1)，即 h<=log[m/2]\((n+1)/2+1)

![image-20230724172944340](./assets/image-20230724172944340.png)

![image-20230724171843466](./assets/image-20230724171843466.png)

![image-20230724172635714](./assets/image-20230724172635714.png)

![image-20230724172903538](./assets/image-20230724172903538.png)

#### 插入操作

- 在插入key后，若导致原节点关键字数超过上限

  - 从中间位置（[m/2]）将其中的关键字分为两部分

  - 左部分包含的关键字放在原节点中

  - 右部分包含的关键字放到新节点中

  - 中间位置（[m/2]）的节点插入原节点的父节点

  - 若此时导致其**⽗结点的关键字个数**也超过了上限，则继续进⾏这种分裂操作，直⾄这个过程传到根结点为⽌，进

    ⽽导致*B*树**⾼度增*1***。

- 新元素一定是插入到最底层“终端节点”，用查找来确定插入位置

  - 原因：B树的失败节点只能出现在最下面一层

![image-20230724173338522](./assets/image-20230724173338522.png)

![image-20230724173316457](./assets/image-20230724173316457.png)

![image-20230724174442318](./assets/image-20230724174442318.png)

##### 错误示范

![image-20230724174452820](./assets/image-20230724174452820.png)

##### 正确示范

![image-20230724174612505](./assets/image-20230724174612505.png)

![image-20230724174624053](./assets/image-20230724174624053.png)

![image-20230724174723342](./assets/image-20230724174723342.png)

![image-20230724174737753](./assets/image-20230724174737753.png)

![image-20230724174750008](./assets/image-20230724174750008.png)

![image-20230724174801298](./assets/image-20230724174801298.png)

![image-20230724174917720](./assets/image-20230724174917720.png)

![image-20230724174927975](./assets/image-20230724174927975.png)

![image-20230724174938113](./assets/image-20230724174938113.png)

![image-20230724174949101](./assets/image-20230724174949101.png)

![image-20230724174959449](./assets/image-20230724174959449.png)

![image-20230724175010391](./assets/image-20230724175010391.png)

![image-20230724175022162](./assets/image-20230724175022162.png)

![image-20230724175113722](./assets/image-20230724175113722.png)

##### 核心要求

1. 对于m阶B树——除根节点外，节点关键字个数[m/2]-1 <= n <= m-1
2. 子树0 < 关键字1 < 子树1 < 关键字2 < 子树2 < ...

新元素一定是插入到最底层“终端节点”，用“查找”来确定插入位置

在插入key后，若导致原节点关键字数超过上限

- 从中间位置（[m/2]）将其中的关键字分为两部分

- 左部分包含的关键字放在原节点中

- 右部分包含的关键字放到新节点中

- 中间位置（[m/2]）的节点插入原节点的父节点

- 若此时导致其**⽗结点的关键字个数**也超过了上限，则继续进⾏这种分裂操作，直⾄这个过程传到根结点为⽌，进

  ⽽导致*B*树**⾼度增*1***。

![image-20230724175515975](./assets/image-20230724175515975.png)

#### 删除操作

- 本质：要永远保证 ⼦树0<关键字1<⼦树1<关键字2<⼦树2<…

- 若被删除关键字在**终端节点**，则直接删除该关键字（要注意节点关键字个数是否低于下限[m/2]-1）

  - 关键字个数高于下限，直接删除

  - 关键字个数低于下限

    - 兄弟够借：若与此节点右（或左）兄弟节点的关键字个数还很宽裕，则需要调整该节点、右（或左）兄弟节点及其双亲节点（父子换位法）

      用当前节点的后继、后继的后继来填补空缺

    - 兄弟不够：若被删除关键字所在节点删除前的关键字个数低于下限，且此时与该节点相邻的左、右兄弟节点的关键字个数均 = [m/2]-1，则将关键字删除后与**左（或右）兄弟节点及双亲节点中的关键字**进行合并

      - 在合并过程中，双亲结点中的关键字个数会减*1*。若**其双亲结点是根结点且关键字个数减少⾄*0***（根结点关键

        字个数为*1*时，有*2*棵⼦树），则直接将根结点删除，合并后的新结点成为根；若双亲结点不是根结点，且关

        键字个数减少到 ，则⼜要与它⾃⼰的兄弟结点进⾏调整或合并操作，并重复上述步骤，直⾄符合*B*

        树的要求为⽌。

- 若被删除关键字在**非终端节点**，则用**直接前驱**或**直接后继**来替代被删除的关键字
  - 对非终端节点关键字的删除，必然可以转化为对终端节点的删除操作
  - 直接前驱：当前关键字左侧指针所指子树中“最右下”的元素
  - 直接后继：当前关键字右侧指针所指子树中“最左下”的元素





- 删除60（终端节点，关键字个数大于下限）

![image-20230724175642625](./assets/image-20230724175642625.png)

![image-20230724175703525](./assets/image-20230724175703525.png)

- 删除80（非终端节点）

![image-20230724180158230](./assets/image-20230724180158230.png)

- 删除38（终端节点，关键字个数低于下限（[m/2]-1，右兄弟够借）

![image-20230724180706078](./assets/image-20230724180706078.png)

![image-20230724180801039](./assets/image-20230724180801039.png)

![image-20230724180743887](./assets/image-20230724180743887.png)

![image-20230724180820612](./assets/image-20230724180820612.png)

![image-20230724180834789](./assets/image-20230724180834789.png)

- 删除90（终端节点，关键字个数低于下限（[m/2]-1，左兄弟够借）

![image-20230724181054994](./assets/image-20230724181054994.png)

![image-20230724181106247](./assets/image-20230724181106247.png)

![image-20230724181139105](./assets/image-20230724181139105.png)

- 删除49（终端节点，关键字个数低于下限（[m/2]-1，左右兄弟不够借）

![image-20230724181548842](./assets/image-20230724181548842.png)

![image-20230724181600641](./assets/image-20230724181600641.png)

![image-20230724181612150](./assets/image-20230724181612150.png)

![image-20230724181623803](./assets/image-20230724181623803.png)

![image-20230724181640464](./assets/image-20230724181640464.png)

![image-20230724181710337](./assets/image-20230724181710337.png)

![image-20230724181721590](./assets/image-20230724181721590.png)

![image-20230724181735840](./assets/image-20230724181735840.png)

![image-20230724181748109](./assets/image-20230724181748109.png)



### B+树

![image-20230724190455779](./assets/image-20230724190455779.png)

#### 分块查找

![image-20230724191732976](./assets/image-20230724191732976.png)

#### 定义

- 一棵m阶的B+树需满足下列条件：
  - 每个分支节点最多有m棵子树（孩子节点）
  - 非叶根节点至少两棵子树，其他每个分支节点至少有[m/2]棵子树（保证每个节点不要太空）
  - **节点的子树个数与关键字个数相等**
  - 所有叶节点包含全部**关键字及指向对应记录的指针**，叶节点中将关键字**按大小顺序排列**，并且相邻叶节点按大小顺序相互连接起来
  - 所有分支节点中仅包含它的各个子节点中关键字的最大值及指向其子节点的指针
- B+树支持顺序查找，每个节点中都有顺序，有节点p将叶子节点中的数据从小到大连接起来

![image-20230724191752521](./assets/image-20230724191752521.png)



- 非叶根节点至少两棵子树，其他每个分支节点至少有[m/2]棵子树

![image-20230724192047266](./assets/image-20230724192047266.png)

#### 查找操作

- 要一直找到**叶子节点**



##### 查找成功

![image-20230724192553775](./assets/image-20230724192553775.png)

![image-20230724193232557](./assets/image-20230724193232557.png)

##### 查找失败

![image-20230724193244882](./assets/image-20230724193244882.png)

![image-20230724193310419](./assets/image-20230724193310419.png)

##### 对比：B树的查找

- 查找成功可能停在任何一层

![image-20230724193808032](./assets/image-20230724193808032.png)

##### 顺序查找

![image-20230724194007548](./assets/image-20230724194007548.png)

![image-20230724194017044](./assets/image-20230724194017044.png)

##### B树 VS B+树

- m阶B+树

  - 节点中n个关键字对应n棵子树

  - 根节点的关键字数n∈[1, m]

     其他结点的关键字数n∈[⌈*m*/2⌉, m]

  - 在B+树中，叶节点包含全部的关键字，非叶节点中出现过的关键字也会出现在叶节点中

  - 在B+树中，**叶结点包含信息**，所有**⾮叶结点仅起索引作⽤**，⾮叶结点中的每个索引项只含有对应⼦

    树的**最⼤关键字**和指向**该⼦树的指针**，不含有该关键字对应记录的存储地址

- m阶B树

  - 结点中的n个关键字对应n+1棵⼦树

  - 根节点的关键字数n∈[1, m-1]。

    其他结点的关键字数n∈[⌈*m*/2⌉-1, m-1]

  - 在B树中，各结点中包含的关键字是不重复的

  - B树的节点中都包含了关键字对应的记录的存储地址

![image-20230724194041626](./assets/image-20230724194041626.png)

![image-20230724194115738](./assets/image-20230724194115738.png)

![image-20230724194707895](./assets/image-20230724194707895.png)



#### 应用（与操作系统有关）

- B+树仅保存索引表，非叶节点不含有该关键字对应记录的存储地址
  - 可以使一个磁盘快可以包含更多个关键字，使得B+树的阶更大，树高更矮，读磁盘次数更少，查找更快

![image-20230724195012681](./assets/image-20230724195012681.png)



## 散列表

- 通常不考代码，着重掌握手算分析方法

### 基本概念

#### 散列表、散裂函数

- 散列表（哈希表，Hash Table）
  - 一种数据结构
  - 特点：可以根据数据元素的关键字计算出它在散列表中的存储地址
    - 查找
      - 先根据散列函数 H(key) 计算出目标元素在散列表中的存储地址
      - 然后检查这个位置的元素就可以知道是查找成功还是失败
    - 理想情况下，在散列表中查找一个元素的时间复杂度为O(1)

- 散列函数（哈希函数）
  - Addr = H(key) 建立了**“关键字”->“存储地址”**的映射关系



![image-20230724200816330](./assets/image-20230724200816330.png)

#### 冲突、同义词

- 冲突（碰撞）

  - 在散列表中插入一个数据元素时，需要根据关键字的值确定其存储地址
  - 若该地址已经存储了其他元素，则称这种情况为“冲突（碰撞）”

- 同义词

  - 若不同的关键字通过散列函数映射到同一个存储地址，则称它们为“同义词”

- 如何减少冲突？

  - 构造更合适的散列函数，让各个关键字尽可能的映射到不同的存储位置，从而减少“冲突”

  

![image-20230724201328970](./assets/image-20230724201328970.png)

![image-20230724201711759](./assets/image-20230724201711759.png)



#### 如何处理冲突

##### 拉链法（链接法、链地址法）

- 把所有“同义词”存储到一个链表中

![image-20230724202026658](./assets/image-20230724202026658.png)

##### 开放定址法

- 如果发生冲突，就给新元素找一个空闲位置

- 用什么规则确定另一个空闲位置？

  

### 构造操作

![image-20230724202339055](./assets/image-20230724202339055.png)

#### 设计散列函数

##### 注意

- 定义域必须涵盖**所有**可能出现的**关键字**
- 值域**不能超出**散列表的地址范围
- 尽可能**减少冲突**。
- 散列表计算出来的地址应尽可能**均匀分布**在整个地址空间

- 散列函数尽可能**简单**，能够快速计算出任意一个关键字对应的散列地址

![image-20230724202936639](./assets/image-20230724202936639.png)



##### 核心目标

- **散列函数要尽可能减少冲突**



##### 除留余数法（最常用）

-  **H(key) = key % p**
- 散列表表长为m，取一个不大于m但最接近或等于m的质数p
  - 原因：对质数取余，可以分布更均匀，从而减少冲突
- 使用场景：较为通用，只要关键字是整数即可

![image-20230724203058513](./assets/image-20230724203058513.png)

![image-20230724203405020](./assets/image-20230724203405020.png)

##### 直接定址法

- **直接定址法 —— H(key) = key 或 H(key) = a\*key + b**
  - a和b是常数。
  - 计算简单，且不会产生冲突。
  - 缺点：若关键字分布不连续，空位较多，则会造成存储空间的浪费
- 使用场景：关键字分布基本连续

![image-20230724203504603](./assets/image-20230724203504603.png)

##### 数字分析法

- 选取数码分布较为平均的若干位作为散列地址
- 设关键字是r进制数（如十进制数），而r个数码在各位上出现的概率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时可以选取数码分布较为均匀的若干位作为散列地址
- 适用场景：**关键字集合已知，且关键字的某几个数码位分布均匀**

![image-20230724203734399](./assets/image-20230724203734399.png)



##### 平方取中法

- 取关键字的平方值的中间几位作为散列地址
- 具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀
- 适用场景：**关键字的每位取值都不够均匀**

![image-20230724210926083](./assets/image-20230724210926083.png)



### 拉链法

#### 核心思想

- 把所有“同义词”存储在一个链表中



#### 插入操作（默认头插法）

- 结合散列函数计算新元素的散列地址
- 将新元素插入散列地址对应的链表（可用头插法，也可用尾插法）

![image-20230724212211642](./assets/image-20230724212211642.png)

![image-20230724212425671](./assets/image-20230724212425671.png)

##### 插入操作的优化

- 新元素插入链表时，保持链表有序，可以略微提高查找效率



#### 查找操作

- 先计算散列地址
- 再查找散列地址里的链表元素



##### 查找长度

- 在查找计算中，需要对比关键字的次数称为查找长度



##### 查找成功

- 查找 27，查找长度=2

![image-20230724212458312](./assets/image-20230724212458312.png)

- 查找 20，查找长度=1

![image-20230724212608907](./assets/image-20230724212608907.png)

##### 查找失败

- 查找 66，查找长度 = 4

![image-20230724212708434](./assets/image-20230724212708434.png)

- 查找21，查找长度=0

![image-20230724212849726](./assets/image-20230724212849726.png)

#### 删除操作

- 先查找
  - 查找成功：删除成功
  - 查找失败：删除失败



##### 删除成功



![image-20230724213007356](./assets/image-20230724213007356.png)

![image-20230724213021343](./assets/image-20230724213021343.png)

##### 删除失败

![image-20230724213108823](./assets/image-20230724213108823.png)

### 开放定址法

![image-20230724213538954](./assets/image-20230724213538954.png)

#### 核心思想

- 如果发生冲突，就给新元素找另一个空闲位置
- 开放定址？
  - 一个散列地址，既对同义词开放，也对非同义词开放
- 用什么规则确定“另一个空闲位置”？
  - 需要确定一个探测顺序：从初始散列地址出发，去寻找下一个空闲位置

#### 插入操作（自己理解的）

- 插入元素，先按照散列函数插入
  - 如果插入位置为空（一个位置一个元素），则直接插入
  - 如果插入位置有人，则根据探测规则 Hi = （H(key) + di）% m 找新位置进行插入，重复以上步骤
- 查找元素，先按照散列函数求值查找
  - 如果查找的位置有元素
    - 查找的元素和存储的元素相同，则查找成功
    - 查找的元素与存储的元素不同，则根据探测规则 Hi = （H(key) + di）% m 找下一个元素进行对比，重复上述过程
  - 如果查找的位置没有元素，查找失败



#### 查找操作

- （自己理解的）查找元素，先按照散列函数求值查找
  - 如果查找的位置有元素
    - 查找的元素和存储的元素相同，则查找成功
    - 查找的元素与存储的元素不同，则根据探测规则 Hi = （H(key) + di）% m 找下一个元素进行对比，重复上述过程
  - 如果查找的位置没有元素，查找失败
- （视频里的）查找操作
  - 与插入操作类似
  - 根据探测序列依次对比各存储单元内的关键字
    - 若探测到目标关键字，则查找成功
    - 若探测到空单元，则查找失败

![image-20230724213643794](./assets/image-20230724213643794.png)

![image-20230724213917963](./assets/image-20230724213917963.png)

![image-20230724214018852](./assets/image-20230724214018852.png)

#### 探测方法

##### 线性探测法

- 线性探测法，**d****i** **= 0, 1, 2, 3, …, m-1**
- 不同序列，探测规则相同
- 可以探测到散列表的每个地址

- 插入操作
  - 先根据散列函数计算插入的位置
    - 如果插入位置为空（一个位置一个元素），则直接插入
    - 如果插入位置有人，则根据探测规则di 找新位置进行插入，重复以上步骤
- 查找操作
  - 与插入操作类似
  - 根据探测序列依次对比各存储单元内的关键字
    - 若探测到目标关键字，则查找成功
    - 若探测到空单元，则查找失败



![image-20230724214234998](./assets/image-20230724214234998.png)

##### 平方探测法（二次探测法）

- 跟线性探测法相同

- 平⽅探测法，*d**i* *= 0**2**, 1**2**, -1**2**, 2**2**, -2**2**, …, k**2**, -k**2*。

  其中*k≤m/2*

![image-20230724215054488](./assets/image-20230724215054488.png)

##### 双散列法

- 双散列法，*di* *= i×hash**2**(key)*
- *hash**2**(key)=13-(key %13)=12*
- 不同的序列，探测规则不同

![image-20230724215231918](./assets/image-20230724215231918.png)

##### 伪随机序列法

- *d**i* 是⼀个伪随机序列，由题⽬可知 *d**i**= 0, 5, 3, 11, …*

![image-20230724215728836](./assets/image-20230724215728836.png)



#### 删除操作

- 先根据散列函数算出散列地址，并对比关键字是否匹配。
  - 若匹配，则查找成功
  - 若不匹配，则根据“探测序列”对比下一个地址的关键字，直到“查找成功”或“查找失败”
- 若查找成功，则删除找到的元素（逻辑删除，做一个已删除的标记）

![image-20230724220231531](./assets/image-20230724220231531.png)

##### 特别注意（不能物理删除）

- 删除元素不能简单地将被删元素的空间置为零，否则将截断在它之后的探测路径，可以做一个“已删除”标记，进行**逻辑删除**



###### 错误示范

![image-20230724220319072](./assets/image-20230724220319072.png)

![image-20230724220328667](./assets/image-20230724220328667.png)

###### 正确示范

![image-20230724220422397](./assets/image-20230724220422397.png)

![image-20230724220634586](./assets/image-20230724220634586.png)

###### 问题

- 查找效率低下，散列表看起来很满，实则很空
- 需要**不定期整理**散列表内的数据
- **新元素可以插入到已被逻辑删除的地址**

![image-20230724220753600](./assets/image-20230724220753600.png)

#### 探测覆盖率

##### 线性探测法

- 一定可以探测到散列表的每个位置
- 只要散列表中有空闲位置，就一定可以插入成功

![image-20230724220929567](./assets/image-20230724220929567.png)

##### 平方探测

- 不能探测到所有位置，只可以探测到散列表中至少一半的位置
- 即使散列表中有空闲位置，也未必能插入成功
- 解决方法
  - 若散列表长度 m 是一个可以表示为 4j+3 的素数（如 7,11,19），平方探测法就能探测到所有位置

![image-20230724221122254](./assets/image-20230724221122254.png)

##### 双散列法

- 未必能探测到散列表的所有位置
- 覆盖率取决于第二个散列函数设计的是否合理
- 结局方法
  - 如果 hash2 计算得到的值与散列表表长 m 互质，就能保证双散列法可以探测到所有单元
  - 令表长 m 本身就是质数，hash2(key)=m-(key%m)

![image-20230724221318939](./assets/image-20230724221318939.png)

##### 伪随机序列

- di 是一个伪随机序列，由程序员人为设计
- 采用伪随机序列法，是否能探测到散列表中全部位置，取决于伪随机序列的设计是否合理

![image-20230724221535492](./assets/image-20230724221535492.png)

![image-20230724221801664](./assets/image-20230724221801664.png)

## 题目

### 思考题

#### 1. 若查找表是“动态查找表”，有没有更好的实现方式：链式存储

<img src="./assets/image-20230720193917761.png" alt="image-20230720193917761" style="zoom:33%;" /><img src="./assets/image-20230720194024307.png" alt="image-20230720194024307" style="zoom:33%;" />



















