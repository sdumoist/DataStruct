# 树和二叉树

## 考点总结

### 思考题

#### 树为什么是一种递归定义的数据结构

树是一种递归定义的数据结构，因为它的定义可以通过对自身的描述进行递归来完成。

树由节点组成，每个节点可以有零个或多个子节点。树的定义可以通过以下方式进行递归描述：

1. 树由一个根节点开始。根节点是树的顶层节点，没有父节点。
2. 每个节点可以有零个或多个子节点。子节点是相对于父节点而言的。
3. 每个子节点本身也可以是一个树，即子树。子树可以看作是原始树的一部分。

这种递归定义的特点在于树的结构可以通过对子树的定义来描述。树的每个节点都可以作为一个根节点，它们可以包含更多的子节点，形成更深层次的结构。

递归定义使得树具有自相似的性质。树的整体结构与其子树的结构类似，这种递归性质使得树在许多算法和数据结构中具有广泛的应用，例如搜索、排序、存储和组织数据等。

通过递归定义，我们可以使用相同的规则来构建树的不同部分，从而形成复杂的树结构。这种递归性质使得树成为一种灵活而强大的数据结构。

#### 线索二叉树寻找前驱后继（先不前，后不继）

- 先不前，后不继
  - 先序线索二叉树不能找先序前驱
  - 后序线索二叉树不能找后序后继
    - 因为只有根能找到自己的左右子树，而且根没有自己的线索（都是左右孩子）
    - 先序遍历的时候：根左右，根在最前面，所以找不到自己的前驱
    - 后序遍历的时候：左右根，根在最后面，所以找不到自己的后继

### 易错点





## 知识总结

![image-20230702130914954](./assets/image-20230702130914954.png)

![image-20230702131951970](./assets/image-20230702131951970.png)

![image-20230702134009965](./assets/image-20230702134009965.png)

![image-20230702161639310](./assets/image-20230702161639310.png)

![image-20230702173836143](./assets/image-20230702173836143.png)

![image-20230702173848860](./assets/image-20230702173848860.png)

![image-20230704214903786](./assets/image-20230704214903786.png)



![image-20230704215842806](./assets/image-20230704215842806.png)

![image-20230704224529787](./assets/image-20230704224529787.png)

![image-20230705155415191](./assets/image-20230705155415191.png)

![image-20230705165109906](./assets/image-20230705165109906.png)

![image-20230705190952703](./assets/image-20230705190952703.png)

![image-20230705191049589](./assets/image-20230705191049589.png)

![image-20230705200603558](./assets/image-20230705200603558.png)

![image-20230705203548373](./assets/image-20230705203548373.png)

![image-20230705213945765](./assets/image-20230705213945765.png)

![image-20230705223222668](./assets/image-20230705223222668.png)

![image-20230706105227305](./assets/image-20230706105227305.png)



## 树

### 基本概念

n(n>=0)个节点的有限集合，n=0时，称为空树。

在任何一棵非空树中应满足：

- 有且仅有一个特定的成为根的节点
- 当n>1时，其余节点可分为m(m>0)个互不相交的有限集合T1,T2,...,Tm,其中每个集合本身又是一棵树，并且成为根节点的子树

![image-20230701165215387](./assets/image-20230701165215387.png)



![image-20230706111114375](./assets/image-20230706111114375.png)

![image-20230706112412312](./assets/image-20230706112412312.png)

### 重要术语

#### 空树

节点数为0的树



#### 根节点

根节点（Root Node）：树的顶层节点，它是树的起点，没有父节点。树中只能有一个根节点。



#### 边

连接两个节点的线段，它表示节点之间的关联关系。在树中，边用于连接父节点与子节点。



#### 分支节点

有后继的节点，也称为非终端节点，内部节点或非叶子节点，是除了根节点以外的其他节点。分支节点至少有一个子节点。



#### 叶子节点

没有后继的节点，也称为终端节点或叶节点，是没有子节点的节点。它们位于树的末端。



#### 前驱

**在树中，节点的前驱是指在树的某一种遍历顺序中，位于该节点之前的节点。**

除了根节点外，任何一个节点都有且仅有一个前驱（根节点没有前驱）



#### 后继

**在树中，节点的后继是指在树的某一种遍历顺序中，位于该节点之后的节点。**

树中的叶子节点没有后继，因为它们没有子节点



#### 祖先节点

对于给定节点，在树中位于其上方的所有节点都是其祖先节点。祖先节点可以是父节点、父节点的父节点，以此类推，直到根节点为止。



#### 子孙节点

对于给定节点，在树中位于其下方的所有节点都是其子孙节点。子孙节点可以是子节点、子节点的子节点，以此类推，直到叶子节点为止。



#### 双亲节点

对于给定节点，它的直接上一级节点称为双亲节点或父节点。每个节点都只有一个父节点，除了根节点没有父节点。



#### 孩子节点

对于给定节点，它的直接下一级节点称为孩子节点或子节点。每个节点可以有零个或多个子节点。



#### 兄弟节点

对于给定节点，具有相同父节点的其他节点称为兄弟节点。兄弟节点之间是同级节点。



#### 堂兄弟节点

给定节点，具有相同祖先节点但不是兄弟节点的节点称为堂兄弟节点。换句话说，堂兄弟节点是具有不同的双亲节点但共享同一级祖先的节点。



#### 两个节点之间的路径

在树中，两个节点之间的路径是指连接这两个节点的边的序列。路径由起始节点开始，沿着树的边连接到目标节点（只能从上到下）。



#### 路径长度

路径长度是指路径上**经过的边的数量**。它表示从起始节点到目标节点之间的距离或步数。

树的路径长度是指树根到每个节点的路径长的总和

根到每个节点的路径长度的最大值应该是树的高度-1

注意与哈夫曼树的带权路径长度的区别



#### 节点的层次（深度）

（从上往下数）默认从1开始，要读题看看是不是第一层，有可能根节点是第0层



#### 节点的高度

（从下往上数）



#### 树的高度（深度）

总共多少层（最多的）



#### 节点的度

有几个孩子（分支）       非叶子节点的度>0



#### 树的度

**各节点的度的最大值**



#### 有序树和无序树

有序树——逻辑上看，树中结点的各子树从左到右是有次序的，不能互换

无序树——逻辑上看，树中节点各子树从左到右是无次序的，可以互换

具体要看用树存什么，是否要用节点的左右位置反应某些逻辑关系

![image-20230702130621646](./assets/image-20230702130621646.png)



#### 树 和 森林

森林是m(m>=0)棵互不相交的树的集合（可以有空森林）

![image-20230702130848399](./assets/image-20230702130848399.png)

### 常考性质

#### 节点数 = 总度数 + 1（根节点没有度数）

#### 度为m的树、m叉树的区别

度为m的树要求比较严格，至少有一个节点的度为m，所以一定是非空树，至少m+1个节点

m叉树要求比较小，只要所以节点的度小于m就可以，可以是空树

![image-20230702131209681](./assets/image-20230702131209681.png)

#### 度为m的树第i层至多有m^(i-1)个节点

![image-20230702131431524](./assets/image-20230702131431524.png)

#### 高度为h的m叉树至多有(m^h-1)/(m-1)个节点

等比数列求和公式：a + aq + aq^2 +......+aq^(n-1)=a(1-q^n)/(1-q)

![image-20230702131624172](./assets/image-20230702131624172.png)

#### 高度为h的m叉树至少有h个节点；高度为h，度为m的树至少有h+m-1个节点

![image-20230702131750880](./assets/image-20230702131750880.png)

#### 有n个节点的m叉树的最小高度是logm(n(m-1)+1)向下取整

![image-20230702131931837](./assets/image-20230702131931837.png)

### 二叉树

#### 定义

n(n>=0)个节点的有限集合

- 或者为空二叉树，即n=0
- 或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树右分别是一颗二叉树



#### 特点

- 每个节点至多只有两颗子树
- 左右子树不能颠倒（二叉树是有序树）

![image-20230702132400074](./assets/image-20230702132400074.png)

#### 二叉树的五种状态

- 空二叉树
- 只有左子树
- 只有右子树
- 只有根节点
- 左右子树都有

![image-20230702132457500](./assets/image-20230702132457500.png)





#### 几个特殊的二叉树

#### 满二叉树

- 一颗高度为h，且含有2^h-1个节点的二叉树

- 特点：
  - 只有最后一层有叶子节点
  - 不存在度为1的节点
  - 按层序从1开始编号，节点i的左孩子为2i，右孩子为2i+1，节点i的父节点为i/2向下取整（如果有的话）

![image-20230702132912536](./assets/image-20230702132912536.png)

#### 完全二叉树

- 当且仅当其每个节点都与高度为h的满二叉树中编号为1～n的节点一一对应时，称为完全二叉树

- 特点

  - 只有最后两层可能有叶子节点
  - 最多只有一个度为1的节点
  - 按层序从1开始编号，节点i的左孩子为2i，右孩子为2i+1，节点i的父节点为i/2向下取整（如果有的话）
  - i<=n/2（向上取整）为分支节点         i>=n/2（向上取整）为叶子节点

  - 如果一个节点只有一个孩子，那一定是左孩子，不是右孩子

![image-20230702133421655](./assets/image-20230702133421655.png)

#### 二叉排序树

- 空二叉树
- 具有如下性质的二叉树：
  - 左子树上所有节点的关键字均小于根节点的关键字
  - 右子树上所有节点的关键字均大于根节点的关键字
  - 左右子树又各是一棵二叉排序树

![image-20230702133719969](./assets/image-20230702133719969.png)

#### 平衡二叉树

- 树上任一节点的左子树和右子树的深度之差不超过1

- 平衡二叉树能有更高的搜索效率

![image-20230702133922676](./assets/image-20230702133922676.png)











#### 二叉树基本常考性质

#### 设非空二叉树中度为0、1、2的节点个数分别是n0,n1,n2，则n0=n2+1（叶子节点比二分支节点多一个）

假设树中结点总数为n，则

1. n=n0+n1+n2
2. n=n1+2n2+1   （树的节点树=总度数+1）

![image-20230702160206974](./assets/image-20230702160206974.png)

#### 二叉树第i层至多有2^(i-1)个节点

![image-20230702160304035](./assets/image-20230702160304035.png)

#### 高度为h的二叉树最多有2*h-1个节点

![image-20230702160346024](./assets/image-20230702160346024.png)

#### 完全二叉树常考性质

#### 具有n个(n>0)节点的完全二叉树的高度为log2(n+1)向下取整或者log2n向上取整+1

高为h的满二叉树共有2^h-1个节点

![image-20230702160719524](./assets/image-20230702160719524.png)

![image-20230702160809404](./assets/image-20230702160809404.png)



#### 对于完全二叉树，可以由节点数推出度为0、1和2的节点个数为n0、n1、n2

完全二叉树最多只有一个度为1的节点，即

- n1=0/1
- n0=n2+1  ---->  n0 + n2 一定是奇数



若完全二叉树有2k个节点，则必有**n1=1,   n0=k,   n2=k-1**

若完全二叉树有2k-1个节点，则必有**n1=0,   n0=k,   n2=k-1**



#### 基本操作

#### i的左孩子

#### i的右孩子

#### i的父亲节点

#### i所在的层次



### 二叉树的存储结构

#### 顺序存储

#### 定义

```C++
#include <stdio.h>
#include <stdlib.h>

/*
    二叉树的顺序存储
*/

#define ElemType int
#define MaxSize 100
struct TreeNode{
    ElemType value; //节点中的数据元素
    bool isEmpty;   //节点是否为空
};

int main(){
    TreeNode t[Maxsize];    //定义一个长度为MaxSize的数组t，按照从上至下、从左到右的顺序依次存储完全二叉树中的各个节点

}
```



#### 初始化

```C++
//初始化树
void InitTree(TreeNode t[]){
    for(int i = 0; i < MaxSize; i ++){
        //初始化时所有节点标记为空
        t[i].isEmpty = true;
    }
}
```



![image-20230702162321119](./assets/image-20230702162321119.png)



#### 基本操作

- i的左孩子：2i
- i的右孩子：2i+1
- i的父节点：i/2向上取整
- i所在的层次：log2(n+1)（向下取整）或log2n+1(向上取整)

若完全二叉树中共有n个节点，则

- 判断i是否有左孩子：2i<= n
- 判断i是否有右孩子：2i+1<=n
- 判断i是否时叶子/分支节点：i>n/2（向上取整）

![image-20230702165242874](./assets/image-20230702165242874.png)

![image-20230702165355081](./assets/image-20230702165355081.png)

非完全二叉树通过isEmpty(TreeNode T)来判断是否有左右孩子

> 二叉树的顺序存储结构只适合存储完全二叉树



#### 链式存储

#### 定义

```C++
#include <stdio.h>
#include <stdlib.h>

/*
    二叉树的链式存储
*/

#define MaxSize 100
typedef struct BiTNode{
    ElemType data;                      //数据域
    struct BiTNode *lchild, *rchild;    //左、右孩子指针
}BiTNode, *BiTree;
```

n个节点的二叉链表共有n+1个空链域（可以用于构造线索二叉树）



#### 初始化

```C++
void InitTree(BiTree &root){
    //插入根节点
    root = (BiTree) malloc(sizeof(BiTNode));
    root->data ={1};
    root -> lchild = NULL;
    root -> rchild = NULL;
}
```



#### 插入新节点

```C++
//插入新节点，作为左孩子
void InsertNewTNode(BiTree &root, ElemType pData){
    BiTNode *p = (BiTNode *) malloc(sizeof(BiTNode));
    p->data=pData;
    p->lchild=NULL;
    p->rchild=NULL;
    root->lchild=p;     //作为根节点的左孩子
}
```



#### 缺点

这种定义方法

- 找到指定节点p的左/右孩子超简单
- 找到指定节点p的父节点很难，只能从根节点开始遍历

![image-20230702173412228](./assets/image-20230702173412228.png)



#### 改进——三叉链表

```C++
//三叉链表————方便找父节点
typedef struct BiTNode{
    ElemType data;                      //数据域
    struct BiTNode *lchild, *rchild;    //左、右孩子指针
    struct BiTNode *parent;             //父节点指针
}BiTNode, *BiTree;
```



## 二叉树的先中后序遍历

**先中后代表着根出现的顺序**

### 遍历

- 按照某中次序把所有节点都访问一遍

- 线性结构很容易进行遍历
- 树可以层次遍历（基于树的层次特性确定的次序规则）也可以先中后序遍历（基于树的递归特性确定的次序规则）

![image-20230704211658740](./assets/image-20230704211658740.png)

### 二叉树的遍历

#### 递归特性

1. 要么是个空二叉树
2. 要么就是由“根节点+左子树+右子树”组成的二叉树



#### 手算口诀（默念）

先序遍历：根左右（NLR）

中序遍历：左根右（LNR）

后序遍历：左右根（LRN）



![image-20230704212420320](./assets/image-20230704212420320.png)

![image-20230704212634674](./assets/image-20230704212634674.png)

![image-20230704212931789](./assets/image-20230704212931789.png)

### 先序遍历

#### 操作过程

1. 若二叉树为空，则什么也不做
2. 若二叉树非空：
   1. 访问根节点；
   2. 先序遍历左子树
   3. 先序遍历右子树

```C++
//先序遍历
void PreOrder(BiTree T){
    if(T!=NULL){
        visit(T);               //访问根节点
        PreOrder(T->lchild);    //递归遍历左子树
        PreOrder(T->rchild);    //递归遍历右子树
    }
}
```

![image-20230704214225071](./assets/image-20230704214225071.png)

![image-20230704214415005](./assets/image-20230704214415005.png)





### 中序遍历
#### 操作过程

1. 若二叉树为空，则什么也不做
2. 若二叉树非空：
   1. 先序遍历左子树；
   2. 访问根节点；
   3. 先序遍历右子树；

```C++
//中序遍历
void InOrder(BiTree T){
    if(T!=NULL){
        PreOrder(T->lchild);    //递归遍历左子树
        visit(T);               //访问根节点
        PreOrder(T->rchild);    //递归遍历右子树
    }
}
```

![image-20230704214442776](./assets/image-20230704214442776.png)



### 后序遍历

#### 操作过程

1. 若二叉树为空，则什么也不做
2. 若二叉树非空：
   1. 先序遍历左子树；
   2. 先序遍历右子树；
   3. 访问根节点；

```C++
//后序遍历
void InOrder(BiTree T){
    if(T!=NULL){
        PreOrder(T->lchild);    //递归遍历左子树
        PreOrder(T->rchild);    //递归遍历右子树
        visit(T);               //访问根节点
    }
}
```

![image-20230704214502599](./assets/image-20230704214502599.png)



### 求树的深度（应用）

```C++
int treeDepth(BiTree T){
    if(T == NULL) return 0;
    else {
        int l = treeDepth(T->lchild);
        int r = treeDepth(T -> rchild);
        //树的深度=Max(左子树深度，右子树深度)+1
        return l>r? l+1:r+1;
    }
}
```



## 二叉树的层序遍历

### 算法思想

1. 初始化一个辅助**队列**
2. 根节点入队
3. 若队列非空，则队头节点入队，访问该节点，并将其左右孩子插入队尾（如果有的话）
4. 重复3直至队列为空

![image-20230704215010029](./assets/image-20230704215010029.png)



```C++

//层序遍历
void LevelOrder(BiTree T){
    LinkQueue Q;
    InitQueue(Q);       //初始化辅助队列
    BiTree p;
    Enqueue(Q,T);       //根节点入队
    while(!IsEmpty(Q)){ //队列不空则循环
        DeQueue(Q,p);   //队头节点出队
        visit(p);       //访问出队节点
        if(p->lchild != NULL) EnQueue(Q,p->lchild); //左孩子入队
        if(p->rchild != NULL) EnQueue(Q,p->rchild); //右孩子入队
    
    }
}
```



## 由遍历序列构造二叉树

### 不同二叉树的中序遍历序列

![image-20230704222841229](./assets/image-20230704222841229.png)

### 若只给出一棵二叉树的前/中/后/层序遍历序列的一种，不能唯一确定一棵二叉树

一定要有中序遍历序列才能确定一棵二叉树

![image-20230704223001314](./assets/image-20230704223001314.png)

### 前序+中序遍历序列

![image-20230704223142717](./assets/image-20230704223142717.png)



![image-20230704223536041](./assets/image-20230704223536041.png)



### 后序+中序遍历序列

![image-20230704223909246](./assets/image-20230704223909246.png)



### 层序+中序遍历序列

 ![image-20230704224354379](./assets/image-20230704224354379.png)



![image-20230704224307205](./assets/image-20230704224307205.png)



## 线索二叉树

### 线索二叉树的作用（更容易寻找遍历后的前驱和后继）

#### 普通二叉树

- 遍历只能从根节点出发，不能从一个指定节点开始中序遍历
- 找到指定节点p在中序遍历中的前驱或者后继，需要从根节点出发重新进行一次中序遍历
  - 用一个指针q记录当前访问的节点，指针pre记录上一个被访问的节点。
  - 当q==p时，pre为前驱
  - 当pre==p时，q为后继

![image-20230704225230624](./assets/image-20230704225230624.png)



#### 中序线索二叉树

![image-20230704225516383](./assets/image-20230704225516383.png)



### 线索二叉树的存储结构

#### 定义

```C++
#define MaxSize 100
typedef ElemType{
    int value;
};

//二叉树节点（链式存储）
typedef struct BiTNode{
    ElemType data;                      //数据域
    struct BiTNode *lchild, *rchild;    //左、右孩子指针
}BiTNode, *BiTree;

//线索二叉树节点
typedef struct ThreadNode{
    ElemType data;
    struct ThreadNode *lchild, *rchild;
    int ltag, rtag;                     //左右线索标志（tag=0，表示指针指向孩子；tag=1，表示指针是线索）
}ThreadNode, *ThreadTree;
```



#### 存储结构

![image-20230705154700122](./assets/image-20230705154700122.png)


#### 中序线索二叉树

![image-20230705154812016](./assets/image-20230705154812016.png)


#### 先序线索二叉树

![image-20230705154921007](./assets/image-20230705154921007.png)



![image-20230705155118817](./assets/image-20230705155118817.png)





#### 后序线索二叉树

![image-20230705155222541](./assets/image-20230705155222541.png)

![image-20230705155239630](./assets/image-20230705155239630.png)



### 二叉树的线索化

#### 中序线索化

> 只有先序线索化的时候才会出现转圈死循环的状态
>
> 因为只有先序线索化是先visit，使得原本为NULL的lchild填充进前驱节点后，再进行PreThread(T->lchild)
>
> 而其他两种遍历都是先访问lchild再visit

#### 用土方法找到中序前驱

![image-20230705161227608](./assets/image-20230705161227608.png)

```C++
//辅助全局变量，用于查找节点p的前驱
BiTNode *p;                 //p指向目标节点
BiTNode *pre=NULL;          //指向当前访问节点的前驱
BiTNode *final=NULL;        //记录最终结果

//访问节点q
void visit(BiTNode *q){
    if(q==p)                //当前访问节点刚好是节点p
        final = pre;        //找到p的前驱
    else pre = q;           //pre指向当前访问的节点
}

//中序遍历
void InOrder(BiTree T){
    if(T!=NULL){
        InOrder(T->lchild);    //递归遍历左子树
        visit(T);               //访问根节点
        InOrder(T->rchild);    //递归遍历右子树
    }
}
```



#### 中序线索化

![image-20230705162744790](./assets/image-20230705162744790.png)

![image-20230705163128107](./assets/image-20230705163128107.png)



```C++
//全局变量pre指向当前访问节点的前驱
ThreadNode *pre = NULL;

void visit(ThreadNode *q){
    if(q->lchild == NULL){              //左子树为空,建立前驱线索
        q->lchild = pre;
        q->ltag = 1;
    }
    if(pre != NULL&&pre->rchild==NULL){
        pre->rchild=q;                  //建立前驱节点的后继节点
        pre->rtag=1;
    }
    pre=q;															//对pre进行更新
}

//中序遍历二叉树，一边遍历一边线索化
void InThread(ThreadNode *q){
    if(T!=NULL){
        InThread(T->lchild);            //中序遍历左子树
        visit(T);                       //访问根节点
        InThread(T->rchild);            //中序遍历右子树
    }

}

//全局线索化二叉树T
void CreateInThread(ThreadTree T){
    pre = NULL;                         //pre初始为NULL
    if(T!= NULL){                       //非空二叉树才能线索化
        InThread(T);                    //中序线索化二叉树
        if(pre->rchild==NULL)           
            pre->rtag=1;                //处理遍历的最后一个节点
    }
}
```



**书上版本**

![image-20230705163356997](./assets/image-20230705163356997.png)



#### 先序线索化

![image-20230705163552658](./assets/image-20230705163552658.png)


> 先序线索化容易出现死循环，所以必须对ltag进行判断

![image-20230705163706180](./assets/image-20230705163706180.png)

- **视频版本**

![image-20230705163818823](./assets/image-20230705163818823.png)

```C++
//全局变量pre指向当前访问节点的前驱
ThreadNode *pre = NULL;

void visit(ThreadNode *q){
    if(q->lchild == NULL){              //左子树为空,建立前驱线索
        q->lchild = pre;
        q->ltag = 1;
    }
    if(pre != NULL&&pre->rchild==NULL){
        pre->rchild=q;                  //建立前驱节点的后继节点
        pre->rtag=1;
    }
    pre=q;															//对pre进行更新
}

//先序遍历二叉树，一边遍历一边线索化
void PreThread(ThreadNode *q){
    if(T!=NULL){
      	visit(T);                        //访问根节点
      	if(T->ltag==0)									 //lchild不是前驱线索
        	PreThread(T->lchild);          //中序遍历左子树
 
        PreThread(T->rchild);            //中序遍历右子树
    }

}

//先序线索化二叉树T
void CreatePreThread(ThreadTree T){
    pre = NULL;                         //pre初始为NULL
    if(T!= NULL){                       //非空二叉树才能线索化
        PreThread(T);                    //先序线索化二叉树
        if(pre->rchild==NULL)           
            pre->rtag=1;                //处理遍历的最后一个节点
    }
}
```



- **书上代码**

![image-20230705164330469](./assets/image-20230705164330469.png)



#### 后序线索化

- **视频代码**

![image-20230705164703509](./assets/image-20230705164703509.png)

```C++
//全局变量pre指向当前访问节点的前驱
ThreadNode *pre = NULL;

void visit(ThreadNode *q){
    if(q->lchild == NULL){              //左子树为空,建立前驱线索
        q->lchild = pre;
        q->ltag = 1;
    }
    if(pre != NULL&&pre->rchild==NULL){
        pre->rchild=q;                  //建立前驱节点的后继节点
        pre->rtag=1;
    }
    pre=q;															//对pre进行更新
}

//后序遍历二叉树，一边遍历一边线索化
void PostThread(ThreadNode *q){
    if(T!=NULL){
        PostThread(T->lchild);            //中序遍历左子树
        PostThread(T->rchild);            //中序遍历右子树
        visit(T);                         //访问根节点
    }

}

//全局线索化二叉树T
void CreatePostThread(ThreadTree T){
    pre = NULL;                         //pre初始为NULL
    if(T!= NULL){                       //非空二叉树才能线索化
        PostThread(T);                    //中序线索化二叉树
        if(pre->rchild==NULL)           
            pre->rtag=1;                //处理遍历的最后一个节点
    }
}
```





- 书上代码

![image-20230705165000736](./assets/image-20230705165000736.png)



### 线索二叉树寻找前驱后继（先不前，后不继）

- 先不前，后不继
  - 先序线索二叉树不能找先序前驱
  - 后序线索二叉树不能找后序后继
    - 因为只有根能找到自己的左右子树
    - 先序遍历的时候：根左右，根在最前面，所以找不到自己的前驱
    - 后序遍历的时候：左右根，根在最后面，所以找不到自己的后继

#### 中序线索二叉树找中序后继

- 在中序线索二叉树中找到指定节点*p的中序后继next
  - 如果p->rtag==1,则next=p->rchild
  - 如果p->rtag==0,则next=p的右子树中最左下节点

```C++
//找到以p为根的子树中，第一个被中序遍历的节点
ThreadNode *Firstnode(ThreadNode *p){
    //循环找到最左下节点(不一定是叶子节点)
    while(p->ltag==0) p=p->lchild;
    return p;
}

//在中序线索二叉树中找到节点p的后继节点
ThreadNode *Nextnode(ThreadNode *p){
    //右子树中最左下节点
    if(p->rtag == 0) return Firstnode(p->rchild);
    else return p->rchild;              //rtag==1直接返回后序线索

}

//对中序线索二叉树进行中序遍历（利用线索实现的非递归算法）
void InOrder(ThreadNode *T){
    for(ThreadNode *p = Firstnode(T); p!=NULL;p=Nextnode(p))
        visit(p);
}
```



![image-20230705172852595](./assets/image-20230705172852595.png)

![image-20230705173819863](./assets/image-20230705173819863.png)



#### 中序线索二叉树找中序前驱

- 在中序线索二叉树中找到指定节点*p的中序前驱pre
  - 如果p->ltag==1,则pre=p->lchild
  - 如果p->ltag==0,则pre=p的左子树中最右下节点

```C++
/*
    中序遍历找前驱
*/
ThreadNode *Lastnode(ThreadNode *p){
    //循环找到最右下节点（不一定是叶节点）
    while(p->rtag==0) p=p->rchild;
    return p;
}

//在中序线索二叉树中找到节点p的前驱节点
ThreadNode *Prenode(ThreadNode *p){
    //左子树中最右下节点
    if(p->ltag==0) return Lastnode(p->lchild);
    else return p->lchild;                      //ltag==1直接返回前驱线索

}

//对中序线索二叉树进行逆向中序遍历
void RevInOrder(ThreadNode *T){
    for(ThreadNode *p = Lastnode(T); p!=NULL; p=Prenode(p))
        visit(p);
}
```



![image-20230705174105589](./assets/image-20230705174105589.png)



![image-20230705174837243](./assets/image-20230705174837243.png)

#### 先序线索二叉树找先序后继

- 在先序线索二叉树中找到指定节点*p的先序后继next
  - 若p->rtag==1,则next=p->rchild
  - 若p->rtag==0
    - 若p有左孩子则先序后继为左孩子
    - 若p没有左孩子，则先序后继为右孩子

```C++
```





![image-20230705175024236](./assets/image-20230705175024236.png)





#### 先序线索二叉树找先序前驱（不行）

![image-20230705175455248](./assets/image-20230705175455248.png)

- 在先序线索二叉树中找到指定节点*p的先序前驱pre

  - 若p->ltag==1,则pre=p->lchild

  - **若p->ltag==0,则先序线索二叉树无法寻找到先序前驱，因为左右子树中的节点只可能是根的后继，不可能是前驱**

    - 除非用土办法从头开始先序遍历

    - 或者使用三叉链表（有一个指向父节点的指针）

      - 如果能找到p的父节点，且**p是左孩子——p的父节点即为其前驱**
      - 如果能找到p的父节点，且**p是右孩子，其左兄弟为空——p的父节点即为其前驱**
      - 如果能找到p的父节点，且**p是右孩子，其左兄弟非空——p的前驱为左兄弟子树中最后一个被先序遍历的节点**
        - 怎么找左兄弟子树中最后一个被先序遍历的节点？
          - （自己的思路）优先寻找左兄弟子树中的右节点，如果没有右节点则寻找左节点，直到叶子节点

      - p是根节点，则p没有前驱节点

![image-20230705175916064](./assets/image-20230705175916064.png)

#### 后序线索二叉树找后序前驱

![image-20230705180603206](./assets/image-20230705180603206.png)

- 在后序线索二叉树中找到指定节点*p的后序前驱pre
  - 若p->ltag==1,则pre=p->lchild
  - 若p->ltag==0
    - 若p有右孩子，则后序前驱为右孩子
    - 若p没有右孩子，则后序前驱为左孩子



#### 后序线索二叉树找后序后继（不行）

![image-20230705181036104](./assets/image-20230705181036104.png)

- 在后序线索二叉树中找到指定节点*p的后序后继next
  - 若p->rtag==1,则next=p->rchild
  - 若p->rtag==0,则后序线索二叉树无法寻找到后序后驱，因为**左右子树中的节点只可能是根的前驱，不可能是后继**
    - 除非用土办法从头开始后序遍历
    - 或者使用三叉链表（有一个指向父节点的指针）
      - 如果能找到p的父节点，且**p是右孩子——p的父节点即为其后继**
      - 如果能找到p的父节点，且**p是左孩子，其右兄弟为空**——**p的父节点即为其前驱**
      - 如果能找到p的父节点，且**p是左孩子，其右兄弟非空**——**p的前驱为右兄弟子树中第一个被后序遍历的节点**
        - 怎么找右兄弟子树中第一个被后序遍历的节点？
          - （自己的思路）优先寻找右兄弟子树中的左节点，如果没有左节点则寻找右节点，直到叶子节点
      - 如果p是根节点，则p没有后序后继



### 三种线索二叉树

#### 三种线索二叉树的对比

![image-20230705155352784](./assets/image-20230705155352784.png)




## 树的存储结构

### 树的逻辑结构

- 树是n (n>=0)个节点的有限集合，n=0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：
  - 有且仅有一个特定的称为根的节点
  - 当n>1时，其余节点可分为m (m>0) 个互不相交的有限集合T1,T2,...,Tm,其中每个集合本身又是一棵树，并且称为根节点的子树
- 树是一种递归定义的数据结构
  - 二叉树：一个分支节点最多只能右两棵子树
  - 树：一个分支节点可以有多棵子树



![image-20230705191624631](./assets/image-20230705191624631.png)



### 回顾：二叉树的顺序存储

![image-20230705191727964](./assets/image-20230705191727964.png)



### 树的顺序存储

- 树：一个分支节点可以有多棵子树
- 只依靠数组下标无法反映节点之间的逻辑关系



#### 树的存储1:双亲表示法

#### 思路

- 用数组顺序存储各个节点。
- **每个节点中保存数据元素、指向双亲节点（父节点）的指针**
- 可以保存森林

#### 优缺点

- 优点：
  - 找双亲（父节点）很方便

- 缺点
  - 找孩子节点很不方便，只能从头遍历整个数组
- 比较适用于找父亲多，找孩子少的应用场景。如：并查集

#### 代码实现

```C++
/*
    树的存储：双亲表示法
*/

#define MAX_TREE_SIZE 100     //树中最多的节点数
typedef struct{
    ElemType data;              //树的节点定义
    int parent;                 //双亲位置域
}PTNode;

typedef struct{                 //树的类型定义
    PTNode nodes[MAX_TREE_SIZE];//双亲表示
    int n;                      //节点数
}
```



![image-20230705192015342](./assets/image-20230705192015342.png)

![image-20230705192413802](./assets/image-20230705192413802.png)

#### 树的存储2:孩子表示法（链式存储+顺序存储）

#### 思路

- 用数组顺序存储各个节点。
- 每个节点中保存数据元素、孩子链表头指针
- 也可以存储森林

#### 优缺点

- 优点
  - 找孩子很方便
- 缺点
  - 找双亲（父节点）不方便，只能遍历每个链表
- 适用于找孩子多，找父亲少的应用场景，如：服务流程树

#### 代码实现

```C++
#include <stdio.h>
#include <stdlib.h>

/*
    树的存储：孩子表示法
*/
#define ElemType int
#define MAX_TREE_SIZE 100

struct CTNode{
    int child;      //孩子节点在数组中的位置
    struct CTNode *next;  //下一个孩子
};

typedef struct{
    ElemType data;
    struct CTNode *firstChild;
} CTBox;

typedef struct {
    CTBox nodes[MAX_TREE_SIZE];
    int n, r;				//节点数和根的位置
} CTree;
```





![image-20230705192920354](./assets/image-20230705192920354.png)



![image-20230705193937268](./assets/image-20230705193937268.png)

![image-20230705194259393](./assets/image-20230705194259393.png)



#### 树的存储3:孩子兄弟表示法（链式存储结构）

#### 思路

- 与二叉树类似，采用二叉链表实现（左孩子右兄弟）
- 每个节点内保存数据元素和两个指针，但两个指针的含义与二叉树节点不同
- 也可以存储森林，将森林中每棵树的根节点视为平级的兄弟关系



![image-20230705195912056](./assets/image-20230705195912056.png)

![image-20230705200149154](./assets/image-20230705200149154.png)



## 哈夫曼树

### 带权路径长度

- **节点的权**：有某种现实含义的数值（如：节点的重要性）
- **节点的带权路径长度**：从树的根到该节点的路径长度（经过的边数）与该节点上权值的乘积
- **树的带权路径长度：**树中所有叶子节点的带权路径长度之和（WPL，Weighted Path Length)

![image-20230705201213503](./assets/image-20230705201213503.png)

### 定义

在含有n个带权叶子节点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称最优二叉树

![image-20230705201331984](./assets/image-20230705201331984.png)

### 构造

- 给定n个权值分别为w1,w2,...,w3的节点，构造哈夫曼树的算法描述如下：
  1. 将n个节点分别作为n棵仅含一个节点的二叉树，构成森林F
  2. 构造一个新节点，从F中选取两棵根节点权值最小的树作为新节点的左、右子树，并且将新节点的权值置为左、右子树上根节点的权值之和
  3. 从F中 删除刚才选出的两棵树，同时将新的到的树加入F中
  4. 重复步骤2和3，直至F中只剩下一棵树为止



### 性质

- 每个初始节点最终都成为叶节点，且权值越小的节点到根节点的路径越大
- 哈夫曼树的节点总数是2n-1
- 哈夫曼树中不存在度为1的点
- 哈夫曼树并不唯一，但WPL必然相等且为最优解

![image-20230705202000675](./assets/image-20230705202000675.png)



### 哈夫曼编码

#### 固定长度编码

- 每个字符用相等长度的二进制位表示



#### 可变长度编码

- 允许对不同字符用不等长的二进制位表示



#### 前缀编码

- 没有一个编码是另一个编码的前缀
- 前缀码解释无歧义



#### 意义

- 用哈夫曼树得到哈夫曼编码——字符集中的每个字符作为一个叶子节点，各个字符出现的频度作为节点的权值，根据之前的方法构造哈夫曼树
- 哈夫曼树不唯一，因此哈夫曼编码不唯一
- 哈夫曼编码可以用于数据的压缩





![image-20230705202705501](./assets/image-20230705202705501.png)

![image-20230705203033880](./assets/image-20230705203033880.png)

![image-20230705203455986](./assets/image-20230705203455986.png)



## 树、森林和二叉树的转换（孩子兄弟表示法）

### 树转二叉树

#### 转换技巧

1. 现在二叉树中，画一个根节点
2. 按“树的层序”依次处理每个节点



#### 方法

- 如果当前处理的节点在树中有孩子，就**把所有孩子节点“用右指针串成糖葫芦”**，并在二叉树中把第一个孩子挂在当前节点的左指针下面

![image-20230705204752770](./assets/image-20230705204752770.png)

![image-20230705205010792](./assets/image-20230705205010792.png)



### 森林转二叉树

#### 注意

- 森林中各棵树的根节点视为平级的兄弟关系



#### 转换技巧

1. 先把所有树的根节点画出来，在二叉树中用右指针串成糖葫芦
2. 按**森林的层序**依次处理每个节点



#### 方法

- 如果当前处理的节点在树中有孩子，就把所有孩子节点“用右指针串成糖葫芦”，并在二叉树中把第一个孩子挂在当前节点的左指针下方

![image-20230705205544107](./assets/image-20230705205544107.png)

![image-20230705212821411](./assets/image-20230705212821411.png)



### 二叉树转树

#### 转换技巧

1. 先画出树的根节点
2. 从树的根节点开始，按照**“树的层序”**恢复每个节点的孩子



#### 方法

- 如何恢复一个节点的孩子：在二叉树中，如果当前处理的节点有左孩子，就把左孩子和“一整串右指针糖葫芦”拆下来，按顺序挂在当前节点的下方

![image-20230705213239895](./assets/image-20230705213239895.png)

![image-20230705213402764](./assets/image-20230705213402764.png)





### 二叉树转森林

#### 转换技巧

1. 先把二叉树的根节点和“一整串右指针糖葫芦”拆下来，作为多棵树的根节点
2. 按“森林的层序”恢复每个节点的孩子



#### 方法

- 在一个二叉树中，如果当前处理的节点有左孩子，就把左孩子和“一整串右指针糖葫芦”拆下来，按顺序挂在当前节点的下方



![image-20230705213839951](./assets/image-20230705213839951.png)



## 并查集

### 应用

#### 使用克鲁斯卡尔Kruskal算法求图的最小生成树

![image-20230814204400581](./assets/image-20230814204400581.png)

- **判断是否加入一条边**
  - 先查找这条边关联的两个顶点是否属于同一个集合
    - 即判断加入这条边之后是否形成回路
  - 若形成回路，则继续判断下一条边
  - 若形不成回路，则将该边和边对应的顶点加入最小生成树 T，并继续判断下一条边
  - 直到所有顶点都已经加入最小生成树 T

#### 判断无向图的连通性

![image-20230814204606124](./assets/image-20230814204606124.png)

- 用并查集判断无向图连通性的方法
  - 遍历无向图的边，每遍历到一条边，就把这条边连接的两个顶点合并到同一个集合中
  - 处理完所有边之后，只要是相互连通的顶点都会被合并到同一个子集合中，相互不连通的顶点一定在不同的子集合中



![image-20230705214230148](./assets/image-20230705214230148.png)

### 逻辑结构——集合

逻辑结构分为：线性结构、树形结构、图结构、集合

#### 全集S

- 包含所有元素

#### 子集S0，S1，S2...

- 将各个元素划分为若干个**互不相交**的子集

#### 集合关系

- A和B属于同一个集合S0
- A和H属于不同的集合

![image-20230705214456468](./assets/image-20230705214456468.png)

### 森林

- 森林是m（m>=0)棵互不相交的树的集合
- 各个子集中的各个元素，可以组织成一棵树
- 三棵树可以组成森林



### 如何表示“集合关系”（并 AND 查）

#### 用互不相交的树，表示多个“集合”

#### 如何“**查**”到一个元素到底属于哪一个集合

- 从指定元素出发，一路向上，直到找到根节点



#### 如何判断两个元素是否属于同一个集合？

- 分别查到两个元素的根，判断根节点是否相等即可



#### 如何把两个集合“并”为一个集合？

- 让一棵树成为另一棵树的子树即可

![image-20230705215232833](./assets/image-20230705215232833.png)

### 并查集存储结构

#### 类比: 树的存储——双亲表示法

![image-20230705215357726](./assets/image-20230705215357726.png)

![image-20230705215613856](./assets/image-20230705215613856.png)

![image-20230705215739328](./assets/image-20230705215739328.png)



### “并查集”的代码实现

- 并 和 查

```C++
//Find “查”操作 找x所属集合（返回x所属根节点）
int Find(int S[], int x){
    while(S[x]>=0)              //循环寻找x的根
        x=S[x];
    return x;                   //根的S[]小于0
}


//Union “并”操作 将两个集合合并为一个
void Union(int S[],int Root1, int Root2){
    //要求Root1和Root2是两个不同的集合
    if(Root1 == Root2) return;
    //将根Root2连接到另一根Root1下面
    S[Root2]=Root1;
}
```



#### 总代码

```C++
#include <stdio.h>
#include <stdlib.h>

/*
    并查集
    树的存储：双亲表示法
    通过int S[]这样一个数组来实现
*/
#define SIZE 13
#define MAX_TREE_SIZE 100     //树中最多的节点数
#define ElemType int

int UFSets[SIZE];               //集合元素数组

typedef struct{
    ElemType data;              //树的节点定义
    int parent;                 //双亲位置域
}PTNode;

typedef struct{                 //树的类型定义
    PTNode nodes[MAX_TREE_SIZE];//双亲表示
    int n;                      //节点数
};

//初始化并查集
void Initial(int S[]){
    for(int i = 0; i < SIZE; i++) S[i] = -1;
}

//Find "查"操作 找x所属集合（返回x所属根节点）
int Find(int S[],int x){
    while(S[x]>=0)              //循环寻找x的根
        x=S[x];
    return x;                   //根的S[]小于0；
}

//Union “并”操作 将两个集合合并为一个
void Union(int S[],int Root1, int Root2){
    //要求Root1和Root2是两个不同的集合
    if(Root1 == Root2) return;
    //将根Root2连接到另一根Root1下面
    S[Root2]=Root1;
}

```

#### 时间复杂度分析(与并查集树的高度有关)

![image-20230814204810890](./assets/image-20230814204810890.png)

- 最好时间复杂度：O(1)
- 最坏时间复杂度：O(n)

![image-20230705221938113](./assets/image-20230705221938113.png)



### ”并查集“的优化    

- 优化后find()最坏时间复杂度为log2(n)  树高不超过log2(n)+1

#### 优化思路

- 每次Union操作构建树的时候，尽可能让树不长高高
  - 用根节点的绝对值表示树的节点总数（-number）
  - **Union操作，让小树合并到大树**

```C++
//Union操作优化 “并”操作 小树合并到大树
void Union(int S[],int Root1, int Root2){
    if(Root1 == Root2) return;
    if(S[Root2]>S[Root1]){      //Root2节点数更少
        S[Root1] += S[Root2];   //累加节点总数
        S[Root2] = Root1;
    }else{
        S[Root2]+=S[Root1];     //累加节点总数
        S[Root1]=Root2;         //小树合并到大树
    }
}
```



![image-20230705222408759](./assets/image-20230705222408759.png)



![image-20230705223039955](./assets/image-20230705223039955.png)



### 并查集的终极优化

#### Find操作的优化（压缩路径）

```C++
//Find 查操作 找x所属集合（返回x所属根节点）
int Find(int S[],int x){
  while(S[x]>=0) x=S[x];	//循环寻找x的根
  return x;
}
```

```C++
//Find 查操作优化 先找到根节点  再进行“压缩路径”
int Find(int S[], int x){
    int root = x;
    while(S[root]>=0) root=S[root];     //循环找到根节点
    while(x!=root){                     //压缩路径
        int t=S[x];                     //t指向x的父节点
        S[x]=root;                      //x直接挂到根节点下
        x=t;
    }

    return root;                        //返回根节点的编号
}
```



#### 思路

- 先找到根节点
- 再将查找路径上所有节点都挂到根节点下

![image-20230706110456300](./assets/image-20230706110456300.png)

#### 优点

- 每次Find操作，先找根，再“压缩路径”，可使树的高度不超过O(a(n)).
- a(n)是一个增长很缓慢的函数，对于常见的n值（<10000)，通常a(n)<=4,因此优化后并查集的Find、Union操作时间开销都很低

![image-20230706110840907](./assets/image-20230706110840907.png)

### 总结两次优化

![image-20230706110938473](./assets/image-20230706110938473.png)

![image-20230706111114375](./assets/image-20230706111114375.png)





## 树、森林的遍历

### 树的遍历

树是一种递归定义的数据结构

#### 先根遍历（深度优先遍历，类似二叉树的先序遍历）

- 若树非空，先访问根节点，再依次对每棵子树进行先根遍历

```C++
//树的先根遍历
void PreOrder(TreeNode *R){
    if(R!=NULL){
        visit(R);       //访问根节点
        while(R还有下一个子树T)
            PreOrder(T);    //先根遍历下一棵子树
    }
}
```

![image-20230705225317743](./assets/image-20230705225317743.png)

#### 后根遍历(深度优先遍历，类似二叉树的中序遍历)

- 若树非空，先依次对每棵子树进行后根遍历，最后再访问根节点

```C++
//根的后根遍历
void PostOrder(TreeNode *R){
    if(R!=NULL){
        while(R还有下一个子树T)
            PostOrder(T);   //后根遍历下一棵子树
        visit(R);           //访问根节点
    }
}
```

![image-20230705225849576](./assets/image-20230705225849576.png)



#### 层序遍历（广度优先遍历）

- 用队列实现
  - 若树非空，则根节点入队
  - 若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队
  - 重复2直到队列为空

![image-20230706103738593](./assets/image-20230706103738593.png)

### 森林的遍历

#### 先序遍历

- 森林是m(m>=0)棵互不相交的树的集合。每棵树去掉根节点后，其各个子树又组成森林



##### 规则

- **效果等同于依次对各个树进行先根遍历，对二叉树进行先序遍历**

- 若森林非空，则按如下规则进行遍历
  1. 访问森林中第一棵树的根节点
  2. 先序遍历第一棵树中根节点的子树森林
  3. 先序遍历除去第一棵树之后剩余的树组成的森林

![image-20230706104545434](./assets/image-20230706104545434.png)



#### 中序遍历

##### 规则

- **效果等同于依次对各个树进行后根遍历，对二叉树进行中序遍历**

- 若森林非空，则按一下规则进行遍历：
  1. 中序遍历森林中第一棵树的根节点的子树森林
  2. 访问第一棵树的根节点
  3. 中序遍历除去第一棵树之后剩余的树构成的森林

![image-20230706105316336](./assets/image-20230706105316336.png)











