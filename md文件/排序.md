# 排序

https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

## 考点总结

- 堆插入删除过程中，关键字对比次数



## 知识总结

![image-20230724224004190](./assets/image-20230724224004190.png)

![image-20230725152123705](./assets/image-20230725152123705.png)

![image-20230725160050422](./assets/image-20230725160050422.png)

![image-20230725162425916](./assets/image-20230725162425916.png)

![image-20230725174048936](./assets/image-20230725174048936.png)

![image-20230725175748489](./assets/image-20230725175748489.png)

![image-20230725195653067](./assets/image-20230725195653067.png)

![image-20230725201620490](./assets/image-20230725201620490.png)

![image-20230725210510348](./assets/image-20230725210510348.png)

![image-20230725215127204](./assets/image-20230725215127204.png)

![image-20230725224348354](./assets/image-20230725224348354.png)

![image-20230726143444178](./assets/image-20230726143444178.png)

![image-20230726145617274](./assets/image-20230726145617274.png)

![image-20230726152812736](./assets/image-20230726152812736.png)



## 基本概念

### 定义

- 排序（sort），就是重新排列表中的元素，使表中的元素满足按关键字有序的过程
  - 输入：n 个记录 R1,R2,...,Rn对应的关键字为 k1，k2，k3
  - 输出：输入序列的一个重排，使得有 K1<=K2<=K3...<=KN（也可以递减）

![image-20230724223313575](./assets/image-20230724223313575.png)

### 应用



### 评价指标

#### 时间复杂度



#### 空间复杂度



#### 稳定性

- 若待排序表中有两个元素*Ri*和*Rj*，其对应的关键字相同即key*i* = key*j*，且在排序前*Ri*在*Rj*的前⾯，若使⽤某⼀排序算法排序后，*Ri*仍然在*Rj*的前⾯，则称这个排序算法是稳定的，否则称排序算法是不稳定的。

  - 稳定的：关键字相同的元素在排序之后**相对位置**不变

  - 不稳定的：排序之后相对位置会改变

- 稳定的排序算法不一定比不稳定排序算法好，看实际需求

![image-20230724223453761](./assets/image-20230724223453761.png)



### 分类

#### 内部排序

- 数据都在内存中
- 关注点：如何让算法时空复杂度更低



#### 外部排序

- 数据太多，无法全部放入内存

- 关注点：如何使读、写磁盘次数更少

![image-20230724223944694](./assets/image-20230724223944694.png)



## 插入排序

### 算法思想

- 每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成



![image-20230724225344906](./assets/image-20230724225344906.png)

![image-20230724225359534](./assets/image-20230724225359534.png)

![image-20230724225409283](./assets/image-20230724225409283.png)

![image-20230724225419234](./assets/image-20230724225419234.png)

![image-20230724225435427](./assets/image-20230724225435427.png)

![image-20230724225445134](./assets/image-20230724225445134.png)

![image-20230724225455508](./assets/image-20230724225455508.png)

![image-20230724225506642](./assets/image-20230724225506642.png)

![image-20230724225520263](./assets/image-20230724225520263.png)

![image-20230724225529427](./assets/image-20230724225529427.png)

![image-20230724225539069](./assets/image-20230724225539069.png)

![image-20230724225548863](./assets/image-20230724225548863.png)
![image-20230725144652437](./assets/image-20230725144652437.png)

![image-20230725144701573](./assets/image-20230725144701573.png)

![image-20230725144713594](./assets/image-20230725144713594.png)

![image-20230725144722865](./assets/image-20230725144722865.png)

![image-20230725144735499](./assets/image-20230725144735499.png)

![image-20230725144756848](./assets/image-20230725144756848.png)

![image-20230725144807505](./assets/image-20230725144807505.png)

![image-20230725144818286](./assets/image-20230725144818286.png)

![image-20230725144829170](./assets/image-20230725144829170.png)

![image-20230725144837620](./assets/image-20230725144837620.png)

![image-20230725144846993](./assets/image-20230725144846993.png)

![image-20230725144855740](./assets/image-20230725144855740.png)

![image-20230725144906674](./assets/image-20230725144906674.png)

![image-20230725144915837](./assets/image-20230725144915837.png)



### 算法实现

![image-20230725144949809](./assets/image-20230725144949809.png)

```C++
//直接插入排序
void InsertSort(int A[],int n){
    int i, j, temp;
    for(i = 1; i < n; i ++){             //将各元素插入已排好序的序列中
        if(A[i]<A[i-1]){                //若A[i]关键字小于前驱
            temp=A[i];                  //用temp暂存A[i]
            for(j = i-1; j >= 0 && A[j] > temp; j --)      //检查所有前面已经排好序的元素
                A[j+1]=A[j];            //所有大于temp的元素都将向后挪位
            A[j+1]=temp;
        }
    }
}
```



### 算法实现（带哨兵）

- 优点：不用每轮循环都判断 j>=0

![image-20230725145012208](./assets/image-20230725145012208.png)

```C++
//直接插入排序（带哨兵）
void InsertSort2(int A[], int n){
    int i,j;
    for(i = 2; i <= n; i ++)                //依次将A[2]~A[n]插入到前面已排序序列
        if(A[i]<A[i-1]){                    //若A[0]关键码小于其前驱，将A[i]插入有序表
            A[0] = A[i];                    //复制为哨兵，A[0]不存放元素
            for(j = i-1; A[0]<A[j]; --j)    //从后往前查找待插入位置
                A[j+1] = A[j];              //向后挪位
            A[j+1] = A[0];                  //复制到插入位置
        }

    
}
```



### 算法效率分析

- 空间复杂度：O(1)
- 时间复杂度：主要来自对比关键字、移动元素
  - 若有n个元素，则需要n-1次处理
  - 最好情况：原本有序
    - 共n-1次处理，每一次都只需要对比关键字1次，不用移动元素
    - 最好时间复杂度：O(n)
  - 最坏情况：原本是倒序
    - 第一趟：对比关键字2次，移动元素3次
    - 第二趟：对比关键字3次，移动元素4次
    - ...
    - 第 i 趟，对比关键字i+1次，移动元素i+2次
    - ...
    - 第n-1趟，对比关键字n次，移动元素n+1次
    - 最坏时间复杂度：O(n^2)

- 稳定性：稳定

![image-20230725145527757](./assets/image-20230725145527757.png)

![image-20230725145539397](./assets/image-20230725145539397.png)

![image-20230725145603222](./assets/image-20230725145603222.png)

![image-20230725145616707](./assets/image-20230725145616707.png)



### 算法优化（折半查找）

#### 思路

- 先用折半查找找到应该插入的位置，再移动元素

- 折半查找的终点都是low > high
  - 将 [low, i-1]内的元素全部右移，并将 A[0]复制到low所指位置
  - 当 A[mid] == A[0] 时，为了保证算法的“稳定性”，应继续在 mid 所指位置右边寻找插入位置
  - 为了保证算法的稳定性，即使前面排好序的元素中出现与待插入元素相同的元素，也不能停止查找，直到 low > high

![image-20230725150749312](./assets/image-20230725150749312.png)

```C++
//优化——折半插入排序
void InsertSort(int A[], int n){
    int i, j, low, high, mid;
    for(i = 2; i <= n; i ++){               //依次将A[2]~A[n]插入前面的已排序序列
        A[0] = A[i];                        //将A[i]暂存到A[0]
        low = 1; high = i-1;                //设置折半查找范围
        while(low < high){                  //折半查找（默认递增有序）
            mid = (low + high)/2;           //取中间点
            if(A[mid] > A[0]) high = mid -1;//查找左半子表
            else low = mid + 1;             //查找右半子表
        }
        for(j=i-1;j>=high+1;--j)
            A[j-1] = A[j];                  //统一后移元素
        A[high+1]=A[0];                     //插入操作

    }
}
```

#### 效率分析

- 比起“直接插入排序”，比较关键字的次数减少了，但是移动元素的次数没变
- 整体来看时间复杂度依然是O(n^2)



#### 例子

##### 元素不相等



![image-20230725145928376](./assets/image-20230725145928376.png)

![image-20230725145938369](./assets/image-20230725145938369.png)

![image-20230725145947543](./assets/image-20230725145947543.png)

![image-20230725145959257](./assets/image-20230725145959257.png)

![image-20230725150008971](./assets/image-20230725150008971.png)

![image-20230725150018986](./assets/image-20230725150018986.png)



##### 元素相等

![image-20230725150112106](./assets/image-20230725150112106.png)

![image-20230725150123491](./assets/image-20230725150123491.png)

![image-20230725150136440](./assets/image-20230725150136440.png)

![image-20230725150146489](./assets/image-20230725150146489.png)

![image-20230725150159984](./assets/image-20230725150159984.png)

![image-20230725150211713](./assets/image-20230725150211713.png)

##### 元素最大



![image-20230725150352312](./assets/image-20230725150352312.png)

![image-20230725150402243](./assets/image-20230725150402243.png)



##### 元素最小

![image-20230725150416321](./assets/image-20230725150416321.png)

![image-20230725150426528](./assets/image-20230725150426528.png)

![image-20230725150436234](./assets/image-20230725150436234.png)

![image-20230725150448588](./assets/image-20230725150448588.png)

![image-20230725150500677](./assets/image-20230725150500677.png)

### 对链表进行插入排序

- 移动元素的次数变少，但是关键字对比的次数依然是O(n^2)数量级
- 整体来看时间复杂度依然是O(n^2)



## 希尔排序

- 对直接插入排序对优化

- 先追求表中元素部分有序，再逐渐逼近全局有序

![image-20230725152824128](./assets/image-20230725152824128.png)



### 算法思想

- 先将待排序表分割成若干形如 L[i, i+的, i+2d,... , i +kd] 的“特殊”子表，对各个子表分别进行直接插入排序。
- 缩小增量的，重复上述过程，直到 d=1
- 希尔本人建议：每次将增量缩小一半

![image-20230725152928019](./assets/image-20230725152928019.png)



### 例子1

- d1 = n/2 = 4		d2 = d1/2 = 2		d3 = d2 /2 = 1

- 结果

![image-20230725153128418](./assets/image-20230725153128418.png)



- 第一趟

![image-20230725153144613](./assets/image-20230725153144613.png)

![image-20230725153200461](./assets/image-20230725153200461.png)

![image-20230725153222915](./assets/image-20230725153222915.png)

![image-20230725153211788](./assets/image-20230725153211788.png)

- 第二趟

![image-20230725153247144](./assets/image-20230725153247144.png)

![image-20230725153257347](./assets/image-20230725153257347.png)

![image-20230725153307380](./assets/image-20230725153307380.png)

![image-20230725153317170](./assets/image-20230725153317170.png)

- 第三趟

![image-20230725153331420](./assets/image-20230725153331420.png)

![image-20230725153343624](./assets/image-20230725153343624.png)

![image-20230725153355778](./assets/image-20230725153355778.png)



### 例子2

- d1 = 3		d2 = 1

![image-20230725153630391](./assets/image-20230725153630391.png)

![image-20230725153645310](./assets/image-20230725153645310.png)

![image-20230725153656108](./assets/image-20230725153656108.png)

![image-20230725153713761](./assets/image-20230725153713761.png)

![image-20230725153724639](./assets/image-20230725153724639.png)

![image-20230725153734875](./assets/image-20230725153734875.png)

![image-20230725153746266](./assets/image-20230725153746266.png)

![image-20230725153757283](./assets/image-20230725153757283.png)

### 算法实现

![image-20230725154406706](./assets/image-20230725154406706.png)

```C++
//希尔排序
void ShellSort(int A[], int n){
    int d, i, j;
    //A[0]只是暂存单元，不是哨兵，当j<=0时，插入位置已经找到
    for(d = n/2; d >= 1; d = d/2)           //步长变化
        for(i=d+1; i <= n; ++i)
            if(A[i] < A[i-d]){              //需要将A[i]插入有序增量子表
                A[0] = A[i];                //暂存在A[0]
                for(j = i-d; j>0 && A[0]<A[j]; j-=d)
                    A[j+d]=A[0];
                A[j+d]=A[0];                //插入
            }
}
```



![image-20230725154806049](./assets/image-20230725154806049.png)

![image-20230725154816418](./assets/image-20230725154816418.png)

![image-20230725154825639](./assets/image-20230725154825639.png)

![image-20230725154838147](./assets/image-20230725154838147.png)

![image-20230725154848777](./assets/image-20230725154848777.png)

![image-20230725154900428](./assets/image-20230725154900428.png)

![image-20230725154910366](./assets/image-20230725154910366.png)

![image-20230725154920906](./assets/image-20230725154920906.png)

![image-20230725154931179](./assets/image-20230725154931179.png)

![image-20230725154949914](./assets/image-20230725154949914.png)

![image-20230725155000546](./assets/image-20230725155000546.png)

![image-20230725155011353](./assets/image-20230725155011353.png)

![image-20230725155022441](./assets/image-20230725155022441.png)

![image-20230725155032485](./assets/image-20230725155032485.png)

![image-20230725155042949](./assets/image-20230725155042949.png)

![image-20230725155052204](./assets/image-20230725155052204.png)

![image-20230725155102115](./assets/image-20230725155102115.png)

![image-20230725155111446](./assets/image-20230725155111446.png)

![image-20230725155121248](./assets/image-20230725155121248.png)

![image-20230725155130511](./assets/image-20230725155130511.png)

![image-20230725155140432](./assets/image-20230725155140432.png)

![image-20230725155149787](./assets/image-20230725155149787.png)

![image-20230725155159735](./assets/image-20230725155159735.png)

![image-20230725155241905](./assets/image-20230725155241905.png)

![image-20230725155300190](./assets/image-20230725155300190.png)

![image-20230725155310963](./assets/image-20230725155310963.png)

![image-20230725155321528](./assets/image-20230725155321528.png)

![image-20230725155332944](./assets/image-20230725155332944.png)

![image-20230725155341856](./assets/image-20230725155341856.png)

![image-20230725155351319](./assets/image-20230725155351319.png)

![image-20230725155402164](./assets/image-20230725155402164.png)

![image-20230725155411779](./assets/image-20230725155411779.png)

![image-20230725155433187](./assets/image-20230725155433187.png)

![image-20230725155444532](./assets/image-20230725155444532.png)

![image-20230725155454050](./assets/image-20230725155454050.png)

![image-20230725155502906](./assets/image-20230725155502906.png)

![image-20230725155514600](./assets/image-20230725155514600.png)

![image-20230725155523879](./assets/image-20230725155523879.png)

![image-20230725155533912](./assets/image-20230725155533912.png)

![image-20230725155543142](./assets/image-20230725155543142.png)

![image-20230725155555358](./assets/image-20230725155555358.png)

![image-20230725155606363](./assets/image-20230725155606363.png)

![image-20230725155616005](./assets/image-20230725155616005.png)

### 算法实现2

- 先处理完一个子表，再处理另一个子表





### 算法性能分析

- 时间复杂度
  - 和增量序列 d1, d2, d3... 的选择有关，目前无法通过数学手段证明确切的时间复杂度
  - 最坏时间复杂度为O(n^2),
  - 当n再某个范围时，可以达到 O(n^1.3)

![image-20230725155914064](./assets/image-20230725155914064.png)

- 稳定性：不稳定
- 适用性：仅适用于顺序表，不适用于链表

![image-20230725155953367](./assets/image-20230725155953367.png)



## 交换排序

- 基于交换的排序：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置



### 冒泡排序

#### 算法思想

- 从后往前（或者从前往后）两两比较元素的值，若为逆序（即A[i-1] > A[i]），则交换它们，直到序列比较完
- 这样的过程为一趟冒泡排序
- 每趟冒泡都可以将最小值放到前面（后面），前面已经确定最终位置的元素不用再进行比较
- 总共进行n-1趟冒泡排序

![image-20230725160550692](./assets/image-20230725160550692.png)

![image-20230725160600170](./assets/image-20230725160600170.png)

![image-20230725160611438](./assets/image-20230725160611438.png)

![image-20230725160620131](./assets/image-20230725160620131.png)

![image-20230725160628231](./assets/image-20230725160628231.png)

![image-20230725160641034](./assets/image-20230725160641034.png)

![image-20230725160649382](./assets/image-20230725160649382.png)

![image-20230725160700096](./assets/image-20230725160700096.png)

![image-20230725160708412](./assets/image-20230725160708412.png)

![image-20230725160724568](./assets/image-20230725160724568.png)

![image-20230725160733336](./assets/image-20230725160733336.png)

![image-20230725160741865](./assets/image-20230725160741865.png)

![image-20230725160750306](./assets/image-20230725160750306.png)

![image-20230725160853234](./assets/image-20230725160853234.png)

![image-20230725160902405](./assets/image-20230725160902405.png)

![image-20230725160910616](./assets/image-20230725160910616.png)

![image-20230725160920542](./assets/image-20230725160920542.png)

![image-20230725161020538](./assets/image-20230725161020538.png)

![image-20230725161030698](./assets/image-20230725161030698.png)

![image-20230725161038965](./assets/image-20230725161038965.png)

![image-20230725161047632](./assets/image-20230725161047632.png)

![image-20230725161056330](./assets/image-20230725161056330.png)

![image-20230725161105270](./assets/image-20230725161105270.png)

![image-20230725161115357](./assets/image-20230725161115357.png)

![image-20230725161124407](./assets/image-20230725161124407.png)

![image-20230725161154940](./assets/image-20230725161154940.png)

![image-20230725161332713](./assets/image-20230725161332713.png)

#### 代码实现

![image-20230725161925763](./assets/image-20230725161925763.png)

```C++
//冒泡排序
void swap(int &a, int &b){
    int temp = a;
    a = b;
    b = temp;
}

void BubbleSort(int A[], int n){
    for(int i=0; i < n-1; i ++){
        bool flag = false;                  //表示本趟冒泡排序是否发生交换
        for(int j = n-1; j > i; j--)        //一趟冒泡排序
            if(A[j-1] > A[j]){              //若为逆序
                swap(A[j-1], A[j]);         //交换
                flag = true;
            }
        if(flag == false) return;           //本趟遍历没有发生交换，表示表已经有序
    }
}
```



#### 算法性能分析

- 空间复杂度：O(n)
- 时间复杂度
  - 最好情况：有序
    - 比较次数 = n-1；交换次数 = 0;
    - 最好时间复杂度：O(n)
  - 最坏情况：逆序
    - 比较次数 = (n-1)+(n-2)+...+1= n(n-1)/2 = 交换次数
    - 最坏时间复杂度 = O(n^2)
  - 平均时间复杂度 = O(n^2)
- 稳定性：稳定的

- 适用性：顺序表和链表都适用

![image-20230725162404997](./assets/image-20230725162404997.png)



### 快速排序

#### 算法思想

- 在待排序表[1..n]中选取一个元素 pivot 作为枢纽（或基准，通常取首元素）
- 通过一趟排序将待排序表划分为独立的两部分L[1...k-1]和L[k+1,n]，使得L[1...k-1]中的所有元素小于pivot，L[k+1,n]中的所有元素大于等于pivot
- pivot放在了最终位置 L[k]上
- 这个过程称为一次“划分”

- 然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素都放在了其最终位置上

![image-20230725164902540](./assets/image-20230725164902540.png)

#### 算法实现

- 一次划分

![image-20230725165217109](./assets/image-20230725165217109.png)

![image-20230725165229896](./assets/image-20230725165229896.png)

![image-20230725165242031](./assets/image-20230725165242031.png)

![image-20230725165253940](./assets/image-20230725165253940.png)

![image-20230725165304030](./assets/image-20230725165304030.png)

![image-20230725165312840](./assets/image-20230725165312840.png)

![image-20230725165326259](./assets/image-20230725165326259.png)

![image-20230725165335459](./assets/image-20230725165335459.png)

![image-20230725165344946](./assets/image-20230725165344946.png)

![image-20230725165355208](./assets/image-20230725165355208.png)

![image-20230725165404411](./assets/image-20230725165404411.png)

![image-20230725165414180](./assets/image-20230725165414180.png)

![image-20230725165425152](./assets/image-20230725165425152.png)

![image-20230725165438932](./assets/image-20230725165438932.png)

- 第二次划分（左子表）

![image-20230725165550539](./assets/image-20230725165550539.png)

![image-20230725165646400](./assets/image-20230725165646400.png)

![image-20230725165655414](./assets/image-20230725165655414.png)

![image-20230725165705841](./assets/image-20230725165705841.png)

![image-20230725165714818](./assets/image-20230725165714818.png)

![image-20230725165728560](./assets/image-20230725165728560.png)

![image-20230725165737305](./assets/image-20230725165737305.png)

- 第二次划分（右子表）

![image-20230725165748596](./assets/image-20230725165748596.png)

![image-20230725165757908](./assets/image-20230725165757908.png)

![image-20230725165807664](./assets/image-20230725165807664.png)

![image-20230725165817572](./assets/image-20230725165817572.png)

![image-20230725165828077](./assets/image-20230725165828077.png)

![image-20230725165838514](./assets/image-20230725165838514.png)

![image-20230725165849058](./assets/image-20230725165849058.png)

![image-20230725165906203](./assets/image-20230725165906203.png)

![image-20230725170039023](./assets/image-20230725170039023.png)

- 第三次划分（左子表）

![image-20230725170025626](./assets/image-20230725170025626.png)

![image-20230725170057204](./assets/image-20230725170057204.png)

![image-20230725170107198](./assets/image-20230725170107198.png)

![image-20230725170117092](./assets/image-20230725170117092.png)

![image-20230725170133088](./assets/image-20230725170133088.png)

![image-20230725170918658](./assets/image-20230725170918658.png)

![image-20230725170927903](./assets/image-20230725170927903.png)

#### 代码实现（最重要）

![image-20230725170943141](./assets/image-20230725170943141.png)

```C++
//快速排序
//用第一个元素将待排序序列划分成左右两个部分
int Partition(int A[], int low, int high){
    int pivot=A[low];                       //第一个元素作为枢纽
    while(low < high){                      //用low、high搜索枢纽的最终位置
        while(low < high && A[high] >= pivot) --high;
        A[low] = A[high];                   //比枢纽小的元素移动到左端
        while(low < high && A[low] <= pivot) ++high;    
        A[high]=A[low];                     //比枢纽大的元素移动到右端
    }
    A[low] = pivot;                         //枢纽元素存放到最终位置
    return low;                             //返回存放枢纽的最终位置
}

//快速排序
void QuickSort(int A[], int low, int high){
    if(low < high){                         //递归跳出条件
        int pivotpos = Partition(A, low, high); //划分
        QuickSort(A, low, pivotpos-1);      //划分左子表
        QuickSort(A, pivotpos + 1, high);   //划分右子表
    }
}
```

![image-20230726162750805](./assets/image-20230726162750805.png)



#### 算法效率分析

- 所有内部排序算法中，平均性能最优秀的排序算法

- 时间复杂度

  - **每⼀层的** QuickSort **只需要处理剩余的** **待排序元素，时间复杂度不超过**O(n)

  - 时间复杂度=O(n\*递归层数)

- 空间复杂度

  - 空间复杂度 = O(递归层数)

- 把n个元素组织成二叉树，二叉树的层数就是递归调用的层数

  - n个节点的二叉树
    - 最小高度 = log2n + 1
    - 最大高度 = n
  - 最好时间复杂度 =  O(nlog2n)
  - 最坏时间复杂度 =  O(n^2)
  - 平均时间复杂度 = O(nlog2n)
  - 最好空间复杂度 =  O(log2n)
  - 最坏空间复杂度 = O(n)
  - 最好情况（枢纽在中间）
    - 若每一次选中的“枢纽：将排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高
    - 若每次选中的“枢纽”将待排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高
  - 最坏情况（有序或逆序）
    - 若每一次选中的“枢纽”将待排序序列划分为很不均匀的两个部分，则会导致递归深度增加，算法效率变低
    - 若初始序列有序或逆序，则快速排序的性能最差（每次选中的都是最靠边的元素）

- 优化思路

  - 尽量选择可以把数据中分的枢纽元素
    - 选中头、中、尾三个位置的元素，取中间值作为枢纽元素
    - 随机选一个元素作为枢轴元素

- 稳定性：不稳定

![image-20230725173927315](./assets/image-20230725173927315.png)

![image-20230725173943495](./assets/image-20230725173943495.png)



- 时间复杂度

![image-20230725172049560](./assets/image-20230725172049560.png)



- 空间复杂度

![image-20230725172443319](./assets/image-20230725172443319.png)

- 转换成二叉排序树

![image-20230725172555373](./assets/image-20230725172555373.png)

- 最坏的情况（逆序）

![image-20230725173155889](./assets/image-20230725173155889.png)

- 比较好的情况

![image-20230725173438773](./assets/image-20230725173438773.png)



#### 一趟排序 != 一次划分

- 一趟排序：可以确定多个元素的位置
- 一次划分：只能确定一个元素的位置

![image-20230725174202608](./assets/image-20230725174202608.png)



## 选择排序

- 每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列

### 简单选择排序

#### 算法思想

- 每一趟在待排序元素中选取关键字最小的元素加入有序子序列
  - 如果遇到两个相同的最小元素，则选择位置靠前的
- 最后剩一个不用处理
  - n个元素的简单选择排序需要n-1趟处理

![image-20230725174457542](./assets/image-20230725174457542.png)

![image-20230725174506146](./assets/image-20230725174506146.png)

![image-20230725174515310](./assets/image-20230725174515310.png)

![image-20230725174523975](./assets/image-20230725174523975.png)

![image-20230725174534231](./assets/image-20230725174534231.png)

![image-20230725174547275](./assets/image-20230725174547275.png)

![image-20230725174555452](./assets/image-20230725174555452.png)

![image-20230725174614500](./assets/image-20230725174614500.png)

![image-20230725174627664](./assets/image-20230725174627664.png)

#### 代码实现

![image-20230725175408335](./assets/image-20230725175408335.png)

```C++
//简单选择排序
void swap(int &a, int &b){
    int temp = a;
    a = b;
    b = temp;
}

void SelectSort(int A[], int n){
    for(int i = 0; i < n-1; i++){           //一共进行n-1趟
        int min =i;                         //记录最小元素位置
        for(int j = i + 1; j < n; j++)      //在A[i...n-1]中选择最小的元素
            if(A[j] < A[min]) min = i;      //更新最小元素位置
        if(min != i) swap(A[i], A[min]);    //封装的swap()函数共移动元素3次
    }
}
```

#### 算法性能分析

- 空间复杂度 = O(1)
- 时间复杂度 = O(n^2)
  - 无论有序、逆序、还输乱序，一定需要n-1趟处理
  - 总共需要对比关键字（n-1)+(n-2)+(n-3)+....+1 = n(n-1)/2 次

- 稳定性：不稳定
- 适用性：既可以用于顺序表，也可以用于链表

![image-20230725175721087](./assets/image-20230725175721087.png)

![image-20230725175730921](./assets/image-20230725175730921.png)











### 堆排序（重点）

#### 堆(heap):顺序存储的完全二叉树

- 若n个关键字序列L[1....n] 满足下面某一条性质，则称为堆（Heap）
  - 大根堆（大顶堆）：若满⾜：L(i)≥L(2i)且L(i)≥L(2i+1) （1 ≤ *i* ≤*n*/2 ）
    - 完全二叉树中：根 >= 左右
  - 小根堆（小顶堆）：若满⾜：L(i)≤L(2i)且L(i)≤L(2i+1) （1 ≤ *i* ≤*n*/2 ） 
    - 完全二叉树中：根 <= 左右

![image-20230725180409165](./assets/image-20230725180409165.png)



##### 二叉树的顺序存储

![image-20230725180215700](./assets/image-20230725180215700.png)



#### 构建操作

##### 算法实现

- 堆顶元素关键字最大



##### 简单选择排序 VS 堆排序

- 简单选择排序：每⼀趟在待排序元素中选取关键字最⼤的元素加⼊有序⼦序列

- 堆排序：每⼀趟将堆顶元素加⼊有序⼦序列（与待排序序列中的最后⼀个元素交换）



##### 构建思路

- 思路

  - 把所有非终端节点都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整
  - **在顺序存储的完全二叉树中，非终端节点编号i <= [n/2]**

- 调整

  - 从 i = n/2 开始检查当前节点（i <= n/2）是否满足 **根 >= 左、右**
  - 若不满足，将当前节点与更大的一个孩子互换
  - 若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整**（小元素不断“下坠”）**
  - 小元素无法下坠，则调整完成

  

![image-20230725185515129](./assets/image-20230725185515129.png)

![image-20230725185543386](./assets/image-20230725185543386.png)

![image-20230725190017364](./assets/image-20230725190017364.png)

![image-20230725190026570](./assets/image-20230725190026570.png)

![image-20230725190036919](./assets/image-20230725190036919.png)

![image-20230725190045953](./assets/image-20230725190045953.png)

![image-20230725190056157](./assets/image-20230725190056157.png)

![image-20230725190105695](./assets/image-20230725190105695.png)

![image-20230725190114473](./assets/image-20230725190114473.png)

![image-20230725190125706](./assets/image-20230725190125706.png)

![image-20230725190137290](./assets/image-20230725190137290.png)

![image-20230725190145791](./assets/image-20230725190145791.png)

##### 构建的代码实现

![image-20230725190229628](./assets/image-20230725190229628.png)



```C++
//堆排序
//将以 k 为根的子树调整为大根堆
void HeadAdjust(int A[],int k, int len){
    A[0] = A[k];                            //A[0]暂存子树的根节点
    for(int i = 2*k; i <= len; i *= 2){     //沿key较大的子节点向下筛选
        if(i < len && A[i]<A[i+1])  
            i++;                            //取key较大的子节点的下标
        if(A[0] >= A[i]) break;             //筛选结束
        else{                               
            A[k] =A[i];                     //将A[i]调整到双亲节点上
            k = i;                          //修改k值，以便继续向下筛选
        }
    }
    A[k] = A[0];                            //被筛选节点的值放入最终位置
}

//建立大根堆
void BuildMaxHeap(int A[], int len){
    for(int i = len/2; i > 0; i--)          //从后往前调整所有非终端节点
        HeadAdjust(A, i, len);
}
```

![image-20230725191359187](./assets/image-20230725191359187.png)

<img src="./assets/image-20230725191411362.png" alt="image-20230725191411362" style="zoom: 33%;" /><img src="./assets/image-20230725191632663.png" alt="image-20230725191632663" style="zoom:33%;" />

<img src="./assets/image-20230725191716515.png" alt="image-20230725191716515" style="zoom:33%;" /><img src="./assets/image-20230725191732707.png" alt="image-20230725191732707" style="zoom:33%;" />

<img src="./assets/image-20230725191841331.png" alt="image-20230725191841331" style="zoom:33%;" /><img src="./assets/image-20230725191856662.png" alt="image-20230725191856662" style="zoom:33%;" />

<img src="./assets/image-20230725191938091.png" alt="image-20230725191938091" style="zoom:33%;" /><img src="./assets/image-20230725191951907.png" alt="image-20230725191951907" style="zoom:33%;" />

<img src="./assets/image-20230725192011696.png" alt="image-20230725192011696" style="zoom:33%;" /><img src="./assets/image-20230725192034371.png" alt="image-20230725192034371" style="zoom:33%;" />



##### 排序操作（基于大根堆）

- 选择排序：每一趟在待排序元素中选取关键字最大的元素加入有序子序列
- 堆排序：每一趟将**堆顶元素**加入有序子序列（与待排序序列中的最后一个元素交换），并将**待排序元素序列**再次调整为大根堆
  - 堆排序的堆顶元素就是整个堆中最大的元素

![image-20230725192820097](./assets/image-20230725192820097.png)

![image-20230725193119688](./assets/image-20230725193119688.png)

![image-20230725193139538](./assets/image-20230725193139538.png)

![image-20230725193148450](./assets/image-20230725193148450.png)

![image-20230725193158206](./assets/image-20230725193158206.png)

![image-20230725193210680](./assets/image-20230725193210680.png)

![image-20230725193221058](./assets/image-20230725193221058.png)

![image-20230725193230826](./assets/image-20230725193230826.png)

![image-20230725193241459](./assets/image-20230725193241459.png)

![image-20230725193253337](./assets/image-20230725193253337.png)

![image-20230725193302782](./assets/image-20230725193302782.png)

![image-20230725193311833](./assets/image-20230725193311833.png)

![image-20230725193321733](./assets/image-20230725193321733.png)

![image-20230725193331222](./assets/image-20230725193331222.png)

![image-20230725193340233](./assets/image-20230725193340233.png)

![image-20230725193349899](./assets/image-20230725193349899.png)

![image-20230725193359389](./assets/image-20230725193359389.png)

![image-20230725193410553](./assets/image-20230725193410553.png)

![image-20230725193422264](./assets/image-20230725193422264.png)

![image-20230725193432992](./assets/image-20230725193432992.png)

![image-20230725193442820](./assets/image-20230725193442820.png)

![image-20230725193452779](./assets/image-20230725193452779.png)

![image-20230725193502129](./assets/image-20230725193502129.png)

![image-20230725193511012](./assets/image-20230725193511012.png)

![image-20230725193532774](./assets/image-20230725193532774.png)

![image-20230725193543015](./assets/image-20230725193543015.png)

![image-20230725193552731](./assets/image-20230725193552731.png)

![image-20230725193602185](./assets/image-20230725193602185.png)

![image-20230725193612890](./assets/image-20230725193612890.png)

![image-20230725193717193](./assets/image-20230725193717193.png)



#### 代码实现

![image-20230725193745319](./assets/image-20230725193745319.png)

```C++
//堆排序
//将以 k 为根的子树调整为大根堆
void HeadAdjust(int A[],int k, int len){
    A[0] = A[k];                            //A[0]暂存子树的根节点
    for(int i = 2*k; i <= len; i *= 2){     //沿key较大的子节点向下筛选
        if(i < len && A[i]<A[i+1])  
            i++;                            //取key较大的子节点的下标
        if(A[0] >= A[i]) break;             //筛选结束
        else{                               
            A[k] =A[i];                     //将A[i]调整到双亲节点上
            k = i;                          //修改k值，以便继续向下筛选
        }
    }
    A[k] = A[0];                            //被筛选节点的值放入最终位置
}

//建立大根堆
void BuildMaxHeap(int A[], int len){
    for(int i = len/2; i > 0; i--)          //从后往前调整所有非终端节点
        HeadAdjust(A, i, len);
}

//堆排序
void HeapSort(int A[], int len){
    BuildMaxHeap(A, len);                   //初始建模
    for(int i = len; i>1; i--){             //n-1趟的交换和建堆过程
        swap(A[i], A[1]);                   //堆顶元素和堆底元素交换
        HeadAdjust(A, 1, i-1);              //把剩余的待排序元素整理成堆
    }
}
```

#### 算法效率分析

![image-20230725195011852](./assets/image-20230725195011852.png)

- 时间复杂度

  - BuildMaxHeap(int A[], int len)
    - 一个节点，每下坠一层，最多只需对比关键字2次
    - 若树高为h，某节点在第 i 层，则将这个节点向下调整最多只需要下坠 h-i 层，关键字对比次数不超过 2(h-i)
    - n个节点的完全二叉树树高 h = [log2n] + 1
    - 第 i 层最多有 2^(i-1) 个节点，而只有第 1～(h-1)层的节点才有可能需要下坠调整
    - 结论：建立初始堆的过程中，关键字对比次数不超过4n，**建堆时间复杂度= O(n)**
  
  - HeapSort(int A[], int len)
    - 总共需要下坠n-1层
    - 每下坠一层，最多只需对比关键字2次，每一趟排序复杂度不超过 O(h) = O(log2n)
    - 结论：总的时间复杂度 = O(nlog2n)
  
- 堆排序的时间复杂度 = *O*(*n*) + *O*(*nlog*2*n*) = *O*(*nlog*2*n*) 
  
- 堆排序的空间复杂度 = *O*(1)

- 稳定性：不稳定

![image-20230725194857989](./assets/image-20230725194857989.png)

  ![image-20230725194925131](./assets/image-20230725194925131.png)

![image-20230725195413220](./assets/image-20230725195413220.png)

#### 插入操作

- 对于小根堆
  - 新元素放到表尾，与父节点对比
  - 若新元素比父节点**更小**，则将两者互换
  - 新元素这样一路上升，直到无法继续上升为止
- 对于大根堆
  - 新元素放到表尾，与父节点对比
  - 若新元素比父节点**更大**，则将两者互换
  - 新元素这样一路上升，直到无法继续上升为止

![image-20230725200533958](./assets/image-20230725200533958.png)

![image-20230725200823026](./assets/image-20230725200823026.png)

![image-20230725200832805](./assets/image-20230725200832805.png)

#### 删除操作

- 对于小根堆
  - 被删除的元素用堆底元素替代
  - 比较该元素与**更小的孩子节点**的元素，如果**大于孩子节点**，让该元素不断下坠
  - 直到无法下坠为止
- 对于大根堆
  - 被删除的元素用堆底元素替代
  - 比较该元素与**更大的孩子节点**的元素，如果**小于孩子节点**，让该元素下坠
  - 直到无法下坠为止

![image-20230725201337325](./assets/image-20230725201337325.png)

![image-20230725201352015](./assets/image-20230725201352015.png)

![image-20230725201401545](./assets/image-20230725201401545.png)

![image-20230725201320610](./assets/image-20230725201320610.png)

![image-20230725201416696](./assets/image-20230725201416696.png)



## 归并排序

### 基本概念

- 归并：把两个或多个已经有序的序列合并为一个



#### 二路归并

- **对比 i 、j 所指元素，选择更小的一个放入 k 所指位置**
- 当一个有序序列已经放完之后，另一个有序序列剩下的值可以依次放入合并序列

- 2个有序序列合并成一个

- 每选出一个小元素需要对比关键字1次

![image-20230725203021969](./assets/image-20230725203021969.png)

- 二路归并操作

![image-20230725202651174](./assets/image-20230725202651174.png)

![image-20230725203038524](./assets/image-20230725203038524.png)

![image-20230725203047872](./assets/image-20230725203047872.png)

![image-20230725203059487](./assets/image-20230725203059487.png)

![image-20230725203109773](./assets/image-20230725203109773.png)

![image-20230725203119949](./assets/image-20230725203119949.png)

![image-20230725203130240](./assets/image-20230725203130240.png)

![image-20230725203140609](./assets/image-20230725203140609.png)

![image-20230725203152316](./assets/image-20230725203152316.png)

![image-20230725203207077](./assets/image-20230725203207077.png)

![image-20230725203219245](./assets/image-20230725203219245.png)

#### 4路归并

- 4个有序序列合并成一个

- 每选出一个小元素需要对比关键字3次

![image-20230725203402908](./assets/image-20230725203402908.png)

#### m路归并

- M个有序序列合并成一个

- 每选出一个小元素需要对比关键字m -1次



### 算法实现

- 内部排序中一般采用2路归并



![image-20230725203421526](./assets/image-20230725203421526.png)



### 代码实现

#### 一次归并

```C++
//归并排序
const int n = 10010;
int *B = (int *) malloc(n*sizeof(int));     //辅助数组B

//A[low...mid]和 A[mid+1...high]各自有序，将两部分归并
void Merge(int A[], int low, int mid, int high){
    int i,j,k;
    for(k = low; k<=high; k++)
        B[k]=A[k];                          //将A中所有的元素复制到B中

    for(i = low, j=mid+1, k=i; i<=mid && j<=high; k++){
        if(B[i]<=B[j]) A[k]=B[i++];         //将较小值复制到A中
        else A[k]=B[j++];
    }
    while(i<=mid) A[k++]=B[i++];
    while(j<=high) A[k++]=B[j++];
}
```



![image-20230725204009409](./assets/image-20230725204009409.png)

![image-20230725204827555](./assets/image-20230725204827555.png)

![image-20230725204838432](./assets/image-20230725204838432.png)

![image-20230725204849672](./assets/image-20230725204849672.png)

![image-20230725204859933](./assets/image-20230725204859933.png)

![image-20230725204915610](./assets/image-20230725204915610.png)

![image-20230725204926506](./assets/image-20230725204926506.png)

![image-20230725204937719](./assets/image-20230725204937719.png)

![image-20230725204947549](./assets/image-20230725204947549.png)

![image-20230725205003729](./assets/image-20230725205003729.png)

![image-20230725205017025](./assets/image-20230725205017025.png)

![image-20230725205033397](./assets/image-20230725205033397.png)

![image-20230725205043997](./assets/image-20230725205043997.png)

![image-20230725205055844](./assets/image-20230725205055844.png)

![image-20230725205114216](./assets/image-20230725205114216.png)

#### 归并排序

- 将一个序列从中间分成两个子序列

- 将左右两个子序列分别进行归并排序得到两个有序子序列
- 然后两个子序列进行归并

```C++
//归并排序
const int n = 10010;
int *B = (int *) malloc(n*sizeof(int));     //辅助数组B

//A[low...mid]和 A[mid+1...high]各自有序，将两部分归并
void Merge(int A[], int low, int mid, int high){
    int i,j,k;
    for(k = low; k<=high; k++)
        B[k]=A[k];                          //将A中所有的元素复制到B中

    for(i = low, j=mid+1, k=i; i<=mid && j<=high; k++){
        if(B[i]<=B[j]) A[k]=B[i++];         //将较小值复制到A中
        else A[k]=B[j++];
    }
    while(i<=mid) A[k++]=B[i++];
    while(j<=high) A[k++]=B[j++];
}

void MergeSort(int A[],int low,int high){
    if(low < high){
        int mid = (low + high)/2;           //从中间划分
        MergeSort(A,low,mid);               //对左半部分归并排序
        MergeSort(A,mid+1,high);            //对右半部分归并排序
        Merge(A,low,mid,high);              //归并
    }
}
```

![image-20230725205700754](./assets/image-20230725205700754.png)

### 算法效率分析

- **时间复杂度：归并排序——O(nlog2n)     每趟归并——O(n)    归并次数——O(log2n)**
  - 2路归并到归并树——形态上就是一棵倒立的二叉树
    - 二叉树的第h层最多有2^(h-1)个节点
    - 若树高为h，则应满足 n<=2^(h-1)
    - 即 h-1 = log2n
  - 结论：n个元素进行二路归并排序，归并的趟数log2n，每趟归并时间复杂度O(n)，算法时间复杂度O(n*log2n)
- **空间复杂度 = O(n)，辅助数组B**
- 稳定性：稳定的

![image-20230725205921824](./assets/image-20230725205921824.png)



## 基数排序（Radix Sort）（手算）

- 不是基于比较的排序算法
- 通常基于链式存储实现

![image-20230725214935131](./assets/image-20230725214935131.png)

### 算法实现

- 从**个位**开始进行**分配入队**（队列先进先出），直到最大数字的最高位

- 每次分配完都进行一次收集，按照从9~0的顺序，下一次分配也按照上一次收集的顺序进行分配

- 例子

  - 第一趟

    - 按个位进行分配，**先分配的先入队**
    - 收集结束：得到按**个位递减**排序的序列
  - 第二趟
    
    - 将第一趟收集得到的序列，按十位进行分配，**个位越大的越先入队**
    - 收集结束：得到按**十位递减**排序的序列，**十位相同的按照个位递减**排序
    
  - 第三趟
    - 将第二趟收集得到的序列，按百位进行分配，**十位越大的越先入队**
    - 收集结束：得到按**百位递减**排序的序列，百位相同的按照十位递减排序，十位相同的按照个位递减排序

![image-20230725212520973](./assets/image-20230725212520973.png)

- 文字描述

  - 假设⻓度为n的线性表中每个结点*a**j*的关键字由*d*元组 (*kjd*−1, *kjd*−2, *kjd*−3, . . . , *kj*1, *kj*0) 组成

    其中，0≤kij ≤ r - 1（0≤j＜n, 0≤i≤d - 1），r 称为“基数”（0～9，r=10）

    - 例如：985 由 (9,8,5) 组成
      - 最高位关键字（最主位关键字）：9
      - 最低位关键字（最次位关键字）：5

  - 基数排序得到递减序列的过程如下

    - 初始化： 设置 **r 个空队列**，Qr-1, Qr-2,…, Q0 
    - 按照各个 **关键字位** **权重递增**的次序（个、⼗、百），对 d 个关键字位分别做“分配”和“收集”
    - 分配：顺序扫描各个元素，若当前处理的关键字位=x，则将元素插⼊ Qx 队尾
    - 收集：把 Qr-1, Qr-2,…, Q0 各个队列中的结点依次出队并链接
    

![image-20230725213040387](./assets/image-20230725213040387.png)



- 第一趟 分配+收集

![image-20230725210817695](./assets/image-20230725210817695.png)

![image-20230725210828667](./assets/image-20230725210828667.png)

![image-20230725210844009](./assets/image-20230725210844009.png)

![image-20230725211001130](./assets/image-20230725211001130.png)

![image-20230725210940638](./assets/image-20230725210940638.png)

- 第二趟

![image-20230725211633444](./assets/image-20230725211633444.png)

![image-20230725211905553](./assets/image-20230725211905553.png)

![image-20230725211919446](./assets/image-20230725211919446.png)

![image-20230725211931366](./assets/image-20230725211931366.png)

![image-20230725211949903](./assets/image-20230725211949903.png)

- 第三趟

![image-20230725212348607](./assets/image-20230725212348607.png)

![image-20230725212406668](./assets/image-20230725212406668.png)

![image-20230725212420245](./assets/image-20230725212420245.png)

![image-20230725212430973](./assets/image-20230725212430973.png)

![image-20230725212450165](./assets/image-20230725212450165.png)



### 算法效率分析

```C++
//基数排序
#define Elemtype int
typedef struct LinkNode{
    Elemtype data;
    struct LinkNode *next;
}LinkNode, *LinkList;

typedef struct{
    LinkNode *front, *rear;
}LinkQueue;
```

- 基数排序通常基于链式存储实现
- 空间复杂度 = O(r)：需要 r 个辅助队列
- 时间复杂度 = O(d*(n+r))：一趟分配O(n)，一趟收集O(r)，总共d趟分配收集
- 稳定性：稳定的

![image-20230725213852693](./assets/image-20230725213852693.png)

- 收集一个队列只需要O(1)

![image-20230725214449076](./assets/image-20230725214449076.png)

![image-20230725214510767](./assets/image-20230725214510767.png)

### 应用

![image-20230725214715643](./assets/image-20230725214715643.png)

#### 适合解决的问题

- 数据元素的关键字可以方便的拆分为 d 组，且d较小
- 每组关键字的取值范围不大，即 r 较小
- 数据元素个数 n 较大

![image-20230725214834606](./assets/image-20230725214834606.png)

#### 不适合解决的问题

![image-20230725215006532](./assets/image-20230725215006532.png)



## 外部排序

### 基本概念

#### 外存与内存之间的数据交换

- 外存：磁盘
- 内存
- 操作系统以“块”为单位对磁盘存储空间进行管理，如：每块大小1KB；各个磁盘块内存放着各种各样的数据
- 磁盘的读/写以“块”为单位，数据读入内存后才能被修改，修改完了还要写回磁盘

![image-20230725215415099](./assets/image-20230725215415099.png)

![image-20230725220134285](./assets/image-20230725220134285.png)

![image-20230725220151257](./assets/image-20230725220151257.png)

![image-20230725220446105](./assets/image-20230725220446105.png)

#### 外部排序的原理

- 原因：数据元素太多，无法一次全部读入内存进行排序
- 使用**归并排序**的方法，最少只需要在内存中分配 3 块大小的缓冲区即可对任意一个大文件进行排序
  - 先将两个块的数据传入内存的输入缓冲区1，2
  - 对输入缓冲区1，2的数据进行归并排序，得到有序序列
  - 将输入缓冲区去1，2的数据依次放入输出缓冲区，写回磁盘块
  - 得到一个有序的“**归并段**”（两个磁盘块组成的有序序列）

![image-20230725220216598](./assets/image-20230725220216598.png)

##### 构造初始归并段

- 读入到输入缓冲区

![image-20230725220526055](./assets/image-20230725220526055.png)

- 归并排序

![image-20230725220545500](./assets/image-20230725220545500.png)



- 写入磁盘

![image-20230725220848703](./assets/image-20230725220848703.png)

![image-20230725220900378](./assets/image-20230725220900378.png)

- 得到有序的归并段

![image-20230725220924221](./assets/image-20230725220924221.png)

![image-20230725220953274](./assets/image-20230725220953274.png)



##### 第一趟归并

- 把8个有序子序列（初始归并段）两两归并
  - 将归并好的元素放到输出缓冲区
  - 当输出缓冲区满的时候，写回磁盘块中
  - 缓冲区1 空了就要**⽴即**⽤归并段1 的下⼀块补上
  - 缓冲区2 空了就要**⽴即**⽤归并段2 的下⼀块补上
    - 如果空了，必须要先补上才能进行下一次归并

![image-20230725221326699](./assets/image-20230725221326699.png)

- 读入归并段1的第一块 和 归并段2的第一块

![image-20230725221426212](./assets/image-20230725221426212.png)

- 进行归并排序

![image-20230725221505754](./assets/image-20230725221505754.png)

![image-20230725221532802](./assets/image-20230725221532802.png)

![image-20230725221544580](./assets/image-20230725221544580.png)

- 输出缓冲区满，写回磁盘块

![image-20230725221558304](./assets/image-20230725221558304.png)

![image-20230725221717104](./assets/image-20230725221717104.png)

- 输入缓冲区1空了要立即用归并段1的下一块补上

![image-20230725221805157](./assets/image-20230725221805157.png)

![image-20230725221852638](./assets/image-20230725221852638.png)

![image-20230725221903474](./assets/image-20230725221903474.png)

- 缓冲区2空了就要立即用归并段2的下一块补上

![image-20230725221915227](./assets/image-20230725221915227.png)

![image-20230725221927162](./assets/image-20230725221927162.png)

![image-20230725221946571](./assets/image-20230725221946571.png)

![image-20230725221956549](./assets/image-20230725221956549.png)

![image-20230725222007523](./assets/image-20230725222007523.png)

![image-20230725222017595](./assets/image-20230725222017595.png)

- 结束

![image-20230725222035954](./assets/image-20230725222035954.png)

![image-20230725222317107](./assets/image-20230725222317107.png)

##### 第二趟归并

- 与第一趟相同

![image-20230725222526263](./assets/image-20230725222526263.png)

![image-20230725222630409](./assets/image-20230725222630409.png)

![image-20230725222558152](./assets/image-20230725222558152.png)

![image-20230725222736300](./assets/image-20230725222736300.png)

![image-20230725222748185](./assets/image-20230725222748185.png)

##### 第三趟归并

![image-20230725222836718](./assets/image-20230725222836718.png)

![image-20230725222847815](./assets/image-20230725222847815.png)



#### 时间开销分析

- 外部排序时间开销 = 读写外存的时间 + 内部排序所需时间 + 内部归并所需时间

![image-20230725223001449](./assets/image-20230725223001449.png)

#### 优化思路

##### 多路归并

- 优点

  - 可以减少归并趟数，从而减少磁盘I/O（读写）次数

    - 对 r 个初始归并段，做k路归并，则归并树可⽤ **k** 叉树表示，若树⾼为h，则归并趟数 **= h-1 =** ⌈logkr⌉
    
    - k越⼤，r越⼩，归并趟数越少，读写磁盘次数越少
-   缺点
  - k路归并时，需要开辟k个缓冲区，内存开销增加
  - 每挑选一个关键字需要对比关键字（k-1）次，内部归并所需时间增加  
  

![image-20230725223809286](./assets/image-20230725223809286.png)


![image-20230725223208211](./assets/image-20230725223208211.png)

![image-20230725223256627](./assets/image-20230725223256627.png)

##### 减少初始归并段数量

- 对r个初始归并段，做k路归并，则归并树可用k叉树表示
- 树高为h，则归并趟数 = h-1 = [logkr]
  - k越大，r越小，归并趟数越少，读写磁盘次数越少
- 结论：若能增加初始归并段的长度，则可减少初始归并段数量r

![image-20230725224140759](./assets/image-20230725224140759.png)

![image-20230725224049117](./assets/image-20230725224049117.png)

![image-20230725224104863](./assets/image-20230725224104863.png)

![image-20230725224115937](./assets/image-20230725224115937.png)

![image-20230725224126575](./assets/image-20230725224126575.png)



#### 总结

![image-20230725224424029](./assets/image-20230725224424029.png)

#### 纠正：多路平衡归并

- k路平衡归并
  - 最多只能有k个段归并为一个
  - 每一趟归并中，若有m个归并段参与归并，则经过这一趟处理得到[m/k]个新的归并段

![image-20230725224535205](./assets/image-20230725224535205.png)

##### 反例

![image-20230725224742543](./assets/image-20230725224742543.png)

### 败者树

#### 多路平衡归并带来的问题

- 使用k路平衡归并策略，选出一个最小元素需要对比关键字（k-1）次，导致内部归并所需时间增加

![image-20230725224915899](./assets/image-20230725224915899.png)

#### 定义

- 通俗定义

  - 失败者留在这一回合，胜利者进入下一回合比拼

  - 最后只有一个冠军在所有比拼中获胜
    - 若有8位参赛者，则构造败者树需要7次比拼

- 败者树——可视为⼀棵完全⼆叉树（多了⼀个头头）。
  - *k*个叶结点分别是当前参加⽐较的元素
  - ⾮叶⼦结点⽤来记忆左右⼦树中的“失败者”
  - ⽽胜者往上继续进⾏⽐较，⼀直到根结点。



![image-20230725225342850](./assets/image-20230725225342850.png)

#### 败者树的使用

- 基于已经构建好的败者树，选出新的胜者只需进行3场比赛

![image-20230725225554880](./assets/image-20230725225554880.png)

![image-20230725225605389](./assets/image-20230725225605389.png)

![image-20230725225615486](./assets/image-20230725225615486.png)

![image-20230725225626003](./assets/image-20230725225626003.png)

#### 败者树在多路平衡归并中的应用

- 构成

  - 每个叶子节点对应一个归并段

  - 分支节点记录失败败者来自哪个归并段

  - 根节点记录冠军来自哪个归并段

- 操作

  - k路归并，第一次构造败者树需要对比关键字k-1次

  - 有了败者树，选出最小元素，只需对比关键字[log2k]（向上取整）次



- 第一次构造败者树

![image-20230726142220567](./assets/image-20230726142220567.png)

![image-20230726142241497](./assets/image-20230726142241497.png)

![image-20230726142253675](./assets/image-20230726142253675.png)

- 选出第二个元素

![image-20230726142700556](./assets/image-20230726142700556.png)

![image-20230726142712402](./assets/image-20230726142712402.png)

![image-20230726142742972](./assets/image-20230726142742972.png)

![image-20230726143016081](./assets/image-20230726143016081.png)

#### 实现思路

- k路归并的败者树只需要定义一个长度为k的数组即可
- 数组中的数据
  - Ls[0]代表胜者
  - Ls[1...k-1]代表失败者



![image-20230726143314546](./assets/image-20230726143314546.png)

![image-20230726143325058](./assets/image-20230726143325058.png)





### 置换选择排序

#### 土方法构造初始归并段

- 可以用一片更大的内存区域来进行内部排序
  - 如：可容纳18个记录
  - 每个“初始归并段”可包含18个记录
- 用于内部排序的内存工作区WA可容纳 l 个记录，则每个初始归并段也只能包含 l 个记录，若文件共有 n 个记录，则初始归并段的数量 r = n / l

![image-20230726143821823](./assets/image-20230726143821823.png)



#### 算法实现

- 使⽤**置换-选择**排序，可以让每个初始归并段的⻓度超越内存⼯作区⼤⼩的限制

- 实现过程

  - 初始化归并段输出文件FO

  - 将初始待排序文件 FI 输入到内存工作区 WA 中，将其填满

  - 置换
    - 把内存工作区中最小的元素置换出去，并且记录这一最小元素 MINIMAX
    - 如果后来输入的元素比 MINIMAX 小，则将其进行标记，不输出；而是选择比 MINIMAX 大的最小值进行输出
    - 当被标记的元素满的时候（内存工作区中所有元素都小于 MINIMAX），将之前的输出元素作为一个归并段
    - 选择一个新的归并段

  - 重复置换直到待排序文件为空

![image-20230726145427072](./assets/image-20230726145427072.png)



- 初始化

![image-20230726144452814](./assets/image-20230726144452814.png)

- 第一趟置换

![image-20230726144508572](./assets/image-20230726144508572.png)

![image-20230726144520465](./assets/image-20230726144520465.png)

![image-20230726144539913](./assets/image-20230726144539913.png)

![image-20230726144552112](./assets/image-20230726144552112.png)

![image-20230726144605976](./assets/image-20230726144605976.png)

![image-20230726144617031](./assets/image-20230726144617031.png)

![image-20230726144633311](./assets/image-20230726144633311.png)

- 第二趟置换

![image-20230726145142679](./assets/image-20230726145142679.png)

![image-20230726145159914](./assets/image-20230726145159914.png)

- 第三趟置换

![image-20230726145214685](./assets/image-20230726145214685.png)

![image-20230726145228519](./assets/image-20230726145228519.png)



### 最佳归并树

#### 归并树的性质

- 每个初始归并段看作一个叶子节点，归并段的长度作为节点权值，则
  - **归并树的带权路径长度 WPL = 读磁盘的次数 = 写磁盘的次数**
- 结论：归并过程中的磁盘 I/O 次数 = 归并树的WPL * 2
- 要让磁盘 I/O 次数最少，就要使归并树 WPL 最小 —— 哈夫曼树

![image-20230726145934146](./assets/image-20230726145934146.png)

#### 构造二路归并的最佳归并树

![image-20230726150334074](./assets/image-20230726150334074.png)

#### 多路归并的最佳归并树

- 只有**叶子节点要 乘以 权值进行相加**



- 一般情况

![image-20230726150853636](./assets/image-20230726150853636.png)

- 最佳归并树

![image-20230726151115096](./assets/image-20230726151115096.png)



#### 如果减少一个归并段，利用上述规则，无法得到最佳归并树

![image-20230726151155031](./assets/image-20230726151155031.png)



- 正确做法
  - 对于 k 叉归并，若初始归并段的数量无法满足构成严格的 k 叉归并树，则需要补充几个长度为 0 的“虚段”，再进行 k 叉哈夫曼树的构造
  - 长度为 0 的虚段：在输入缓冲区什么都不用放

![image-20230726151253362](./assets/image-20230726151253362.png)

![image-20230726151446916](./assets/image-20230726151446916.png)

#### 添加虚段的数量（k - 1 - u）

- 对于 k  叉归并，若初始归并段的数量无法构成严格的 k 叉归并树，则需要补充几个长度为 0的虚段，再进行 k 叉哈夫曼树的构造
- k 叉的最佳归并树一定是一棵严格的 k 叉树，即树中只包含度为 k、度为 0的节点
  - 设度为 k的节点有nk个，度为0的节点有 n0个，归并树的总节点数=n
  - 初始归并段数量 + 虚段数量 = n0
  - n = n0 + nk
  - k * nk = n - 1
  - 得到：n0 = (k-1) * nk + 1
  - 结论：**nk = (n0 - 1)/(k - 1)**（如果是严格k叉树，一定能除得尽（所有的数都是整数））
- **若（初始归并段数量 - 1）% （k - 1）= 0；说明刚好可以构成严格 k 叉树，此时不需要添加虚段**
- **若（初始归并段数量 - 1）% （k - 1）= u != 0；则需要补充（k - 1）- u 个虚段**

![image-20230726151816101](./assets/image-20230726151816101.png)



## 练习

### 1. 基于小根堆如何建堆、排序

![image-20230725195756007](./assets/image-20230725195756007.png)





















